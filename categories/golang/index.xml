<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on QWDing blog</title>
    <link>http://blog.qwding.com/categories/golang/</link>
    <description>Recent content in Golang on QWDing blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Nov 2016 12:48:31 +0800</lastBuildDate>
    <atom:link href="http://blog.qwding.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang 几大主流框架对比</title>
      <link>http://blog.qwding.com/post/golang_framwork_pk/</link>
      <pubDate>Fri, 25 Nov 2016 12:48:31 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_framwork_pk/</guid>
      <description>

&lt;h3 id=&#34;先上表格:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;先上表格&lt;/h3&gt;

&lt;p&gt;如下表格是2016-11-24 日调研结果，2~5列为github数据。
&lt;img src=&#34;http://blog.qwding.com/img/golang_framwork_pk.png&#34; width = &#34;800&#34; alt=&#34;图片名称&#34; align=center /&gt;&lt;/p&gt;

&lt;p&gt;benchmark:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/golang_framwork_benchmark.png&#34; width = &#34;800&#34; alt=&#34;图片名称&#34; align=center /&gt;&lt;/p&gt;

&lt;h3 id=&#34;beego-vs-revel-vs-martini-三大老框架:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;beego  VS revel VS martini 三大老框架&lt;/h3&gt;

&lt;p&gt;beego&lt;/p&gt;

&lt;p&gt;beego 很多人比较熟悉，国人写的，框架主要逻辑是经典MVC形式。&lt;/p&gt;

&lt;p&gt;中间件：中间件可以写在beego内置的prepare方法里。&lt;/p&gt;

&lt;p&gt;取参：取Query需要自己提取，url参数可以用内置方法。&lt;/p&gt;

&lt;p&gt;返回：返回比较固定，想修改返回code比较麻烦。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;书写unit testing很恶心。&lt;/p&gt;

&lt;p&gt;他的侵入式代码风格，还有源代码的多层嵌套，很多人都不太喜欢。&lt;/p&gt;

&lt;p&gt;revel&lt;/p&gt;

&lt;p&gt;revel 也是MVC框架，他的的形式是你在一个配置文件配置路由，当用revel工具执行revel run时候，将在项目目录下生产两个文件/tmp/main.go 和 /routs/routs.go .作用分别为注册路由和绑定路由内参数。&lt;/p&gt;

&lt;p&gt;中间件：中间件可以定义在/init.go 里面。&lt;/p&gt;

&lt;p&gt;取参：内置提供方法，并且有自己内置的validation方法，方便。&lt;/p&gt;

&lt;p&gt;返回：提供多种返回方法。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;也是侵入式代码。&lt;/p&gt;

&lt;p&gt;其他的未实际使用，不予评论&lt;/p&gt;

&lt;p&gt;martini&lt;/p&gt;

&lt;p&gt;书写简单，写起来和之后要讲的echo，gin很像，但是他的性能较echo和gin差了很多。&lt;/p&gt;

&lt;p&gt;从功能上说，并且martini并不像beego和revel那样框架全面，需要自己把架子搭起来。&lt;/p&gt;

&lt;p&gt;所以直接就不考虑了。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;性能上beego和revel两者不分伯仲，两者的侵入式代码也是为了节省更多的时间，带来了不少便利。对比起来更倾向于用revel做简单的web框架，他的取参和返回值带来的便利性更高一点，并且也会生成路由的testing方法，综合来讲下一次如果写简单的管理界面可能考虑使用revel。&lt;/p&gt;

&lt;h3 id=&#34;fasthttp-vs-httprouter:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;fasthttp vs httpRouter&lt;/h3&gt;

&lt;p&gt;两者都作为http的框架，可以替代原生的http，他们的优越都是因为速度快，0占用内存著称。可以考虑将他们作为其他框架的http引擎，会提升很大速度。&lt;/p&gt;

&lt;h3 id=&#34;gorilla-mux:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;gorilla mux&lt;/h3&gt;

&lt;p&gt;gorilla 最大好处是他出发点为组件化，各个模块单独成一体，你需要哪个模块，拿过来用就行，不需要可以换成其他写法。&lt;/p&gt;

&lt;p&gt;mux是帮你对router更容易管理，其速度来说并不是非常突出。但是docker swarm用的是gorilla mux，足见其有一定可用性。&lt;/p&gt;

&lt;p&gt;对于gorilla其他模块，如果缺少哪个模块组件，完全去任你挑选，安全稳定可靠，开发好帮手。&lt;/p&gt;

&lt;h3 id=&#34;echo-vs-gin:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;echo VS gin&lt;/h3&gt;

&lt;p&gt;最想说的两个&lt;/p&gt;

&lt;p&gt;无论哪个benchmark，这两个框架的benchmark都已绝对优势排在前列，性能绝对认可。&lt;/p&gt;

&lt;p&gt;代码书写上，两个框架写法也很相似，非常简洁，几行代码可勾勒一个http server,如下为gin一个ping serve，是不是超级简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;github.com/gin-gonic/gin&amp;quot;
func main() {
    r := gin.Default()
    r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;,
        })
    })
    r.Run() // listen and server on 0.0.0.0:8080
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而echo的写法和gin及其相似，就不列举了。&lt;/p&gt;

&lt;p&gt;功能全面来说，虽然简洁，但是功能也很全面，从路由分组，取参，中间件，返回考虑，都封装的使用很舒服。&lt;/p&gt;

&lt;p&gt;其他特点：&lt;/p&gt;

&lt;p&gt;echo：&lt;/p&gt;

&lt;p&gt;可以将http引擎从 echo.standerd 和fasthttp间切换，两者的性能差不太多。&lt;/p&gt;

&lt;p&gt;自带工具全面：websocket, http2, jwt授权等。&lt;/p&gt;

&lt;p&gt;具有中文文档。&lt;/p&gt;

&lt;p&gt;gin：&lt;/p&gt;

&lt;p&gt;日志跟踪比echo更强大，也内置了返回html文件的方法，所以去写web server也会很简单。&lt;/p&gt;

&lt;p&gt;综合来说&lt;/p&gt;

&lt;p&gt;两者相差不太大，但是gin的日志跟踪还是更舒服一点。&lt;/p&gt;

&lt;p&gt;在以后如果想写简单的API server，我会首选gin或echo来使用，更倾向gin,如果你不想看英文文档可以选择echo。其使用的简单太吸引人了。&lt;/p&gt;

&lt;h3 id=&#34;goji-和-tango:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;goji 和 tango&lt;/h3&gt;

&lt;p&gt;这两个是顺便看的，也有一些人推崇这两个，但是使用起来差别也并不是特别大&lt;/p&gt;

&lt;p&gt;tango出发点是以结构体作为执行体的灵活框架，其他好像也并无特色了&lt;/p&gt;

&lt;p&gt;goji貌似更成熟一点，可依赖程度更高&lt;/p&gt;

&lt;h3 id=&#34;总结:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;萝卜白菜，各有所爱。粗略调研统计，跟上时代步伐。&lt;/p&gt;

&lt;p&gt;总结就是如果写简单web server 会考虑 revel，写api server 会首先考虑gin。&lt;/p&gt;

&lt;h3 id=&#34;福利一句话:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;福利一句话&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;上面的比较仅仅是路由的比较，但99%的瓶颈不在路由，而是模版的渲染和数据库操作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;link:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;LINK&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;revel：&lt;a href=&#34;http://revel.github.io/docs/godoc/template.html&#34;&gt;http://revel.github.io/docs/godoc/template.html &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;revel中文： &lt;a href=&#34;http://gorevel.cn/docs/index.html&#34;&gt;http://gorevel.cn/docs/index.html &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;beego: &lt;a href=&#34;http://beego.me&#34;&gt;http://beego.me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;echo: &lt;a href=&#34;https://echo.labstack.com/guide&#34;&gt;https://echo.labstack.com/guide &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gin: &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;https://github.com/gin-gonic/gin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;httpRouter: &lt;a href=&#34;https://github.com/julienschmidt/httprouter&#34;&gt;https://github.com/julienschmidt/httprouter &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gorilla: &lt;a href=&#34;http://www.gorillatoolkit.org/pkg/&#34;&gt;http://www.gorillatoolkit.org/pkg/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;tango: &lt;a href=&#34;http://gobook.io/read/github.com/go-tango/manual-zh-CN/&#34;&gt;http://gobook.io/read/github.com/go-tango/manual-zh-CN/ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;benchmark:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/smallnest/go-web-framework-benchmark&#34;&gt;https://github.com/smallnest/go-web-framework-benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://colobu.com/2016/03/23/Go-HTTP-request-router-and-web-framework-benchmark/&#34;&gt;http://colobu.com/2016/03/23/Go-HTTP-request-router-and-web-framework-benchmark/ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一场越看越有意思的骂战</title>
      <link>http://blog.qwding.com/post/golang_intersting_1/</link>
      <pubDate>Tue, 22 Nov 2016 16:00:09 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_intersting_1/</guid>
      <description>

&lt;h3 id=&#34;有趣的帖子:b429b1d01dbad5b8b090552795c3b36e&#34;&gt;有趣的帖子&lt;/h3&gt;

&lt;p&gt;查些资料，不小心挖了个坟，观战互喷 &lt;a href=&#34;https://www.v2ex.com/t/89374&#34;&gt;https://www.v2ex.com/t/89374&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，看口水战的时候往往还是带了不少信息~&lt;/p&gt;

&lt;p&gt;以此膜拜耿直程序员的耿直精神&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>beego 如何不同环境用不同的runmode</title>
      <link>http://blog.qwding.com/post/beego_runmode/</link>
      <pubDate>Wed, 19 Oct 2016 10:28:28 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/beego_runmode/</guid>
      <description>

&lt;h3 id=&#34;beego-runmode修改:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;beego runmode修改&lt;/h3&gt;

&lt;p&gt;除了配置文件设置runmode，想切换环境时候需要手动改，太麻烦，而且容易忘&lt;/p&gt;

&lt;p&gt;想通过如下两种方法尝试，均无效：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flag，但是beego本身并没有flag，简直行不通&lt;/li&gt;
&lt;li&gt;官方文档里个的方法是 beego.Runmode = &amp;ldquo;dev&amp;rdquo;, 但其实这个方法很鸡肋，很蛋疼，因为读配置文件早在程序运行前执行了，而如果再程序里修改runmode，你在init里用的参数必然还是默认写的，用着基本蛋疼。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我在我本地beego 1.7的环境里又尝试了一下，发现已经没有这个方法了，可能作者也觉得确实蛋疼给删了吧。&lt;/p&gt;

&lt;h3 id=&#34;环境变量改变:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;环境变量改变&lt;/h3&gt;

&lt;p&gt;尝试将配置文件的runmode指定为环境变量，然后指定具体模式。发现居然成功了。不管怎么样，确实这个办法还是一个不错的解决方案了&lt;/p&gt;

&lt;h3 id=&#34;加上docker更好用:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;加上docker更好用&lt;/h3&gt;

&lt;p&gt;因为本来用docker，这样直接在Dockerfile里设置ENV，部署线上的时候，直接用构建好的镜像启动就ok了，什么都不用改了。&lt;/p&gt;

&lt;p&gt;&lt;i&gt; 懒人使人进步&lt;/i&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How golang slice Semi - pointer.</title>
      <link>http://blog.qwding.com/post/slice_args/</link>
      <pubDate>Sun, 09 Oct 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/slice_args/</guid>
      <description>

&lt;h3 id=&#34;起因:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;起因&lt;/h3&gt;

&lt;p&gt;刷leetcode的77题时候，使用了递归方法，并且使用数组时候如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result := make([][]int, 0, length+1)
recursive([]int{}, 1, n, k, result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次使用了cap声明slice，这样的好处是append时候在length后添加数据，并且保证长度够，append时候不会重新申请地址&lt;/p&gt;

&lt;p&gt;但是跑的时候发现，recursive()后，在返回到此段代码，居然什么都没有！result值没变。&lt;/p&gt;

&lt;h1 id=&#34;什么-slice不是传说的指针传递么:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;什么？ slice不是传说的指针传递么？&lt;/h1&gt;

&lt;h1 id=&#34;先看下官方数组结构样子:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;先看下官方数组结构样子&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/slice.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然，一直知道数组是半指针，就是将数组的地址的值传进去。在函数里是改变不了指针的值，但是可以操作指针指向的数据，详细的google有很多&lt;/p&gt;

&lt;p&gt;我想象的是这样：函数收到的是数组的头地址(就是图最上面的指针）,length和cap等数据，这样可以完全接管数组的操作了&lt;/p&gt;

&lt;p&gt;但是上述起因里出现的问题却不是这样，到底是什么原因呢？于是写了测试代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	result := make([]int, 0, 10)
	addr := &amp;amp;result
	fmt.Println(&amp;quot;result:&amp;quot;, result, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))

	for i := 0; i &amp;lt; 10; i++ {
		functions(result)
		result = append(result, i)
		//appendData(result,i)
	}
	fmt.Println(&amp;quot;result:&amp;quot;, result, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))

}

func functions(arr []int) {
	addr := &amp;amp;arr
	if len(arr) &amp;gt; 0 {
		fmt.Println(&amp;quot;arr:&amp;quot;, arr, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr), &amp;quot;arr 0 addr:&amp;quot;, &amp;amp;arr[0])
	} else {
		fmt.Println(&amp;quot;arr:&amp;quot;, arr, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))
	}
}

func appendData(arr []int,data int){
	arr = append(arr,data)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result: [] addr: 0xc420012200
arr: [] addr: 0xc420012260
arr: [0] addr: 0xc4200122a0 arr 0 addr: 0xc4200140f0
arr: [0 1] addr: 0xc4200122e0 arr 0 addr: 0xc4200140f0
arr: [0 1 2] addr: 0xc420012320 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3] addr: 0xc420012360 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4] addr: 0xc4200123a0 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5] addr: 0xc4200123e0 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6] addr: 0xc420012420 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6 7] addr: 0xc420012460 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6 7 8] addr: 0xc4200124a0 arr 0 addr: 0xc4200140f0
result: [0 1 2 3 4 5 6 7 8 9] addr: 0xc420012200
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;居然发现-unsafe-pointer-addr-的值是一直变的-但是-arr-0-是不变的:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;居然发现 unsafe.Pointer(addr)的值是一直变的！但是&amp;amp;arr[0]是不变的！&lt;/h1&gt;

&lt;p&gt;我擦，看来完全想错了，应该是函数里重新创建了一个数组(unsafe.Pointer(addr)一直变说明)，但是把源数组的数据地址拿过来,这个新创建的数组来指向他(&amp;amp;arr[0]不变说明)&lt;/p&gt;

&lt;h1 id=&#34;又测试在function里添加和删除数据-即代码中注释掉的地方去掉-发现返回到main里时是不生效的-所以说明最初猜想是错的:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;又测试在function里添加和删除数据，即代码中注释掉的地方去掉，发现返回到main里时是不生效的，所以说明最初猜想是错的。&lt;/h1&gt;

&lt;h3 id=&#34;修改:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;修改&lt;/h3&gt;

&lt;p&gt;有意思的是当我们修改原有的数据时候，是可以成功的，这就是因为数组元素指向的是原数组的地址，所以修改是生效的&lt;/p&gt;

&lt;h3 id=&#34;妄下结论:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;妄下结论&lt;/h3&gt;

&lt;p&gt;数组在函数传递过程中，在函数里可以更改数组的值，但是不能增和删&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go map,slice,array 遍历性能测试 </title>
      <link>http://blog.qwding.com/post/gotest_map_array_slice/</link>
      <pubDate>Mon, 27 Jun 2016 14:28:44 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/gotest_map_array_slice/</guid>
      <description>

&lt;h1 id=&#34;就是随便试试:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#就是随便试试&lt;/h1&gt;

&lt;p&gt;听说goalng的map和slice的遍历性能差的不是一点半点，于是没事写个benchmark来玩玩
代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package testings

import(
	&amp;quot;testing&amp;quot;
	&amp;quot;strconv&amp;quot;
)

var length = 1000
var maps map[string]string
var slices []string
var arrays [1000]string

func init(){
	maps = make(map[string]string,length)
	slices = make([]string,length)
	for i:=0;i&amp;lt;length;i++{
		maps[strconv.Itoa(i)] = &amp;quot;abc&amp;quot;
		slices[i] = &amp;quot;abc&amp;quot;
		arrays[i] = &amp;quot;abc&amp;quot;
	}

}


func BenchmarkIterateMap(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range maps{
		}
	}
}

func BenchmarkIterateSlices(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range slices{
		}
	}
}

func BenchmarkIterateArrays(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range arrays{
		}
	}
}

func BenchmarkIterateMapF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range maps{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range slices{
			_ = k
		}
	}
}

func BenchmarkIterateArraysF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range arrays{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_ = slices[j]
		}
	}
}

func BenchmarkIterateArraysFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_= arrays[j]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试结果:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#测试结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;➜  testings git:(master) ✗ go test -bench=. iterate_map_vs_slice_vs_array_test.go
testing: warning: no tests to run
PASS
BenchmarkIterateMap-4      	  100000	     20544 ns/op
BenchmarkIterateSlices-4   	 5000000	       368 ns/op
BenchmarkIterateArrays-4   	 5000000	       371 ns/op
BenchmarkIterateMapF-4     	  100000	     21685 ns/op
BenchmarkIterateSlicesF-4  	 2000000	       812 ns/op
BenchmarkIterateArraysF-4  	 1000000	      1036 ns/op
BenchmarkIterateSlicesFor-4	 1000000	      1199 ns/op
BenchmarkIterateArraysFor-4	 1000000	      1024 ns/op
ok  	command-line-arguments	14.858s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;看数据:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#看数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;先看前面三个方法，只是遍历，没有应用数据，大小都是1000，map 居然是slice和array的57倍之多。&lt;/li&gt;
&lt;li&gt;接下来三个方法是应用到了数据，map性能损耗基本没有增多多少，但是slice和array却增多一倍多（还不了解为什么）&lt;/li&gt;
&lt;li&gt;后面两个表明 array的按index取和range取性能不变，但是slice是有差距的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数据不是固定的:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#数据不是固定的&lt;/h3&gt;

&lt;p&gt;将slice和map的大小分布调成10，100，1000，10000，得出的性能比，map/slice是不固定的，也没有发现什么规律(测试不够充分)，但是一般都在将近30倍以上。但是可以得出遍历性能确实差很多。&lt;/p&gt;

&lt;h3 id=&#34;slice-不同情况性能差距也比较大:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#slice 不同情况性能差距也比较大&lt;/h3&gt;

&lt;h3 id=&#34;遗留问题:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#遗留问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;slice 为什么只遍历和取到数据还有一倍多的性能损耗&lt;/li&gt;
&lt;li&gt;slice 的index取数和range取数性能也有差距&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>golang: change instance address in his method</title>
      <link>http://blog.qwding.com/post/golang_struct_func_changeaddr/</link>
      <pubDate>Wed, 01 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_struct_func_changeaddr/</guid>
      <description>

&lt;h3 id=&#34;前提回顾:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;前提回顾&lt;/h3&gt;

&lt;p&gt;对于结构体中的指针应用，大部分可能知道的是如下两代码的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a *AA) funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a AA) funcB()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;区别在于，我们在funcA内修改a的值，是可以成功的，但是在funcB修改a的值是失败的。&lt;/p&gt;

&lt;p&gt;因为funcA中的a是指针传递，funcB中的a是值传递。这个大家都知道。&lt;/p&gt;

&lt;h3 id=&#34;今天话题:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;今天话题&lt;/h3&gt;

&lt;p&gt;先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type AA struct {
	xyz string
	opq string
}

func (this *AA) Change() {
	b := &amp;amp;AA{xyz: &amp;quot;xyz1&amp;quot;, opq: &amp;quot;opq1&amp;quot;}
	this = b
	fmt.Println(&amp;quot;in this:&amp;quot;, this, &amp;quot;addr:&amp;quot;, &amp;amp;this)
}

func main() {
	a := &amp;amp;AA{xyz: &amp;quot;xyz0&amp;quot;, opq: &amp;quot;opq0&amp;quot;}
	fmt.Println(&amp;quot;before a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)

	a.Change()

	fmt.Println(&amp;quot;after a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么问题来了，请回答一下程序执行过程的三个输出是什么。&lt;/p&gt;

&lt;h3 id=&#34;一开始的想法:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;一开始的想法&lt;/h3&gt;

&lt;p&gt;开始简单认为Change方法是指针传递，那么在里面修改了实例的地址，应该是可以实现的，所以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output1 != output2 == output3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;肯定和预想不一样:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;肯定和预想不一样&lt;/h3&gt;

&lt;p&gt;结果图片如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果： &lt;code&gt;output1  == output3 != output2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;面向对象的编程，在编译的时候，会将类的方法进行一下转换，类似如下：&lt;/p&gt;

&lt;p&gt;A.f() 会转换成 Object.f(A)&lt;/p&gt;

&lt;p&gt;而转换后的函数方法，也分值传递和指针传递。而这时候是值传递，导致你无论怎么修改A的地址，在函数外面都不会改变。&lt;/p&gt;

&lt;h3 id=&#34;再清晰一点:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;再清晰一点&lt;/h3&gt;

&lt;p&gt;可以思考一下堆栈的分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr_pic1.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;手拙，用excel画了个堆栈图&lt;/p&gt;

&lt;p&gt;在执行Chang()时，会生成变量this，这个变量this里存的就是传进来值的地址，main函数里的a变量里存的也是这个地址。
所以修改值得时候，两边是互通的。&lt;/p&gt;

&lt;p&gt;但是，我们Chang()函数是修改的this的值，也就是将 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff00 (a_value)&lt;/code&gt; 改成了 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff10(b_value)&lt;/code&gt;  可是在main函数里面a的值还是没有变。所以output3，还是a指向的地址里的值。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>