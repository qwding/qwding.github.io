<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on QWDing blog</title>
    <link>http://blog.qwding.com/post/</link>
    <description>Recent content in Posts on QWDing blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jun 2016 19:19:58 +0800</lastBuildDate>
    <atom:link href="http://blog.qwding.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang 在实例方法内修改实例地址测试</title>
      <link>http://blog.qwding.com/post/golang_struct_func_changeaddr/</link>
      <pubDate>Wed, 01 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_struct_func_changeaddr/</guid>
      <description>

&lt;h3 id=&#34;前提回顾:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;前提回顾&lt;/h3&gt;

&lt;p&gt;对于结构体中的指针应用，大部分可能知道的是如下两代码的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a *AA) funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a AA) funcB()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;区别在于，我们在funcA内修改a的值，是可以成功的，但是在funcB修改a的值是失败的。&lt;/p&gt;

&lt;p&gt;因为funcA中的a是指针传递，funcB中的a是值传递。这个大家都知道。&lt;/p&gt;

&lt;h3 id=&#34;今天话题:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;今天话题&lt;/h3&gt;

&lt;p&gt;先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type AA struct {
	xyz string
	opq string
}

func (this *AA) Change() {
	b := &amp;amp;AA{xyz: &amp;quot;xyz1&amp;quot;, opq: &amp;quot;opq1&amp;quot;}
	this = b
	fmt.Println(&amp;quot;in this:&amp;quot;, this, &amp;quot;addr:&amp;quot;, &amp;amp;this)
}

func main() {
	a := &amp;amp;AA{xyz: &amp;quot;xyz0&amp;quot;, opq: &amp;quot;opq0&amp;quot;}
	fmt.Println(&amp;quot;before a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)

	a.Change()

	fmt.Println(&amp;quot;after a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么问题来了，请回答一下程序执行过程的三个输出是什么。&lt;/p&gt;

&lt;h3 id=&#34;一开始的想法:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;一开始的想法&lt;/h3&gt;

&lt;p&gt;开始简单认为Change方法是指针传递，那么在里面修改了实例的地址，应该是可以实现的，所以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output1 != output2 == output3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;肯定和预想不一样:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;肯定和预想不一样&lt;/h3&gt;

&lt;p&gt;结果图片如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果： &lt;code&gt;output1  == output3 != output2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;面向对象的编程，在编译的时候，会将类的方法进行一下转换，类似如下：&lt;/p&gt;

&lt;p&gt;A.f() 会转换成 Object.f(A)&lt;/p&gt;

&lt;p&gt;而转换后的函数方法，也分值传递和指针传递。而这时候是值传递，导致你无论怎么修改A的地址，在函数外面都不会改变。&lt;/p&gt;

&lt;h3 id=&#34;再清晰一点:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;再清晰一点&lt;/h3&gt;

&lt;p&gt;可以思考一下堆栈的分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr_pic1.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;手拙，用excel画了个堆栈图&lt;/p&gt;

&lt;p&gt;在执行Chang()时，会生成变量this，这个变量this里存的就是传进来值的地址，main函数里的a变量里存的也是这个地址。
所以修改值得时候，两边是互通的。&lt;/p&gt;

&lt;p&gt;但是，我们Chang()函数是修改的this的值，也就是将 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff00 (a_value)&lt;/code&gt; 改成了 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff10(b_value)&lt;/code&gt;  可是在main函数里面a的值还是没有变。所以output3，还是a指向的地址里的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo vs hexo</title>
      <link>http://blog.qwding.com/post/hugo_vs_hexo/</link>
      <pubDate>Fri, 08 Apr 2016 18:51:19 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/hugo_vs_hexo/</guid>
      <description>

&lt;h3 id=&#34;hugo-和-hexo-对比:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;hugo 和 hexo 对比&lt;/h3&gt;

&lt;p&gt;主要是查阅了一下很多人经验，并汇总了一下对比结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                     hexo                           hugo
速度                  快                           特别快
主题           几大主题基础上延伸,总量更多     很多,良好主题生态圈
安装及更新       更新容易有坑，因为依赖包       一个binary,安装更新快
评论系统           支持disqus等                   支持disqus等
应用方面          博客适应性更强	             非博客适应性更强
文档              有中文文档                    文档超详细，中文不全
功能            分类,tag,多语言,i18n       分类,tag,series,wight,多语言

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为本身更喜欢golang，所以选择了hugo&lt;/p&gt;

&lt;h3 id=&#34;分享一下查阅的资料:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;分享一下查阅的资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://beebom.com/2015/04/best-static-site-generators&#34;&gt;十种静态页面生成工具&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hexo.io/&#34;&gt;hexo 文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hexo.io/zh-cn/docs/&#34;&gt;hexo 中文文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/465830080ea9&#34;&gt;hexo 一篇比较好的使用文章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.gohugo.io/overview/quickstart/&#34;&gt;hugo 文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.gohugo.org/doc&#34;&gt;hugo 中文文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;hugo 主题&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gitlab-pages:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;gitlab pages&lt;/h3&gt;

&lt;p&gt;gitlab 8.3以后也出了github pages的功能，但只限gitlab-ee版本，需要付费&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://doc.gitlab.com/omnibus/docker/&#34;&gt;gitlab-ee docker安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://doc.gitlab.com/ee/pages/README.html&#34;&gt;gitlab pages使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一个开始</title>
      <link>http://blog.qwding.com/post/main/</link>
      <pubDate>Fri, 08 Apr 2016 11:57:57 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/main/</guid>
      <description>

&lt;h3 id=&#34;写点博客总是好的:379caad01b6ea305187be199bcac1370&#34;&gt;写点博客总是好的&lt;/h3&gt;

&lt;p&gt;长点心，写点博客，少打游戏。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://blog.qwding.com/post/portus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.qwding.com/post/portus/</guid>
      <description>

&lt;p&gt;date = &amp;ldquo;2016-04-20T11:48:19+08:00&amp;rdquo;
description = &amp;ldquo;contrast hugo with hexo&amp;rdquo;
highlight = true
categories = [&amp;ldquo;portus&amp;rdquo;,&amp;ldquo;registry&amp;rdquo;]
title = &amp;ldquo;portus的docker容器搭建&amp;rdquo;
index = true
+++&lt;/p&gt;

&lt;h3 id=&#34;一般形式:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;一般形式&lt;/h3&gt;

&lt;p&gt;在官方文档，或者百度谷歌，搜到的portus一般都是compose形式搭建，这样好处是操作无脑&lt;/p&gt;

&lt;p&gt;但是一般情况下我们肯定是自己要更灵活一些的，肯定用docker容器形式更舒服一点。可是去dockerhub一搜，各种版本的镜像，查看dockerfile很多人都自己加了一些内容，对于不会ruby的人来说，并不知道那些操作都说干啥的。&lt;/p&gt;

&lt;h3 id=&#34;自己研究研究:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;自己研究研究&lt;/h3&gt;

&lt;p&gt;github master分支上有dockerfile，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM library/rails:4.2.2
MAINTAINER Flavio Castelli &amp;lt;fcastelli@suse.com&amp;gt;

ENV COMPOSE=1
EXPOSE 3000

WORKDIR /portus
COPY Gemfile* ./
RUN bundle install --retry=3

# Install phantomjs, this is required for testing and development purposes
# There are no official deb packages for it, hence we built it inside of the
# open build service.
RUN echo &amp;quot;deb http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/ ./&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list
RUN wget http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/Release.key &amp;amp;&amp;amp; \
  apt-key add Release.key &amp;amp;&amp;amp; \
  rm Release.key
RUN apt-get update &amp;amp;&amp;amp; \
    apt-get install -y --no-install-recommends phantomjs &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*

ADD . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是直接用那个dockerfile直接build一个镜像。参考别人给出的一些docker run参数启动，并成功了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -e RAILS_ENV=production \
	-e RACK_ENV=production \
	-e PORTUS_SECRET_KEY_BASE=secret-goes-here \
	-e PORTUS_KEY_PATH=/certs/server-key.pem \
	-e PORTUS_PASSWORD=portuspw \
	-e PORTUS_CHECK_SSL_USAGE_ENABLED=false \
	-e PORTUS_MACHINE_FQDN_VALUE=192.168.56.101 \
	-e PORTUS_PRODUCTION_HOST=192.168.56.101 \
	-e PORTUS_PRODUCTION_USERNAME=portus \
	-e PORTUS_PRODUCTION_PASSWORD=portus \
	-e PORTUS_PRODUCTION_DATABASE=portus \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	--restart=always \
	-p 5001:3000 portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下这些参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PORTUS_SECRET_KEY_BASE 是rails 4.0以后出的一个web安全参数，一般要rake secret生成一个很长很长的随机串，发现随意写个串也无妨。&lt;/li&gt;
&lt;li&gt;PORTUS_KEY_PATH 猜测是对应registry给出那个crt的。&lt;/li&gt;
&lt;li&gt;PORTUS_PASSWORD 这个参数有意思。在你创建好portus后，需要创建一个用户叫 portus。密码就是这个密码。这个用户的目的是为了同步镜像用的。（之后说）&lt;/li&gt;
&lt;li&gt;PORTUS_CHECK_SSL_USAGE_ENABLED 因为我没有官方签发证书，所以用http，如果https，在registry的notifications时候会发不过去。&lt;/li&gt;
&lt;li&gt;PORTUS_MACHINE_FQDN_VALUE 就是你的portus要配置的域名。&lt;/li&gt;
&lt;li&gt;PORTUS_PRODUCTION_HOST，PORTUS_PRODUCTION_USERNAME，PORTUS_PRODUCTION_PASSWORD，PORTUS_PRODUCTION_DATABASE这几个就是数据库的地址，帐号，密码，数据库&lt;/li&gt;
&lt;li&gt;puma -b tcp://0.0.0.0:3000 -w 3 是执行的CMD，试了一下，这个镜像默认是什么都不执行的，所以启动可以添加这个命令，如果不想每次加可以在dockerfile里加上CMD.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简化一下:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;简化一下&lt;/h3&gt;

&lt;p&gt;显然，如上启动方式跟了一大堆参数是很烦的，也不是你想的。当然那就把它们放到配置文件里。&lt;/p&gt;

&lt;p&gt;主要有三个配置文件都放在了 Portus/config 文件夹下。分别为 config.yml, database.yml, secrets.yml&lt;/p&gt;

&lt;p&gt;将几个env变量都可以配置到文件的production里。&lt;/p&gt;

&lt;p&gt;值得注意的是，PORTUS_MACHINE_FQDN_VALUE这个变量在2.0.3版本里是放在了secrets.yml 里，但是如果你用的是portus的master分支，最新的代码是放在config.yml里的。一坑。&lt;/p&gt;

&lt;p&gt;所以启动方式可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d \
	-e RAILS_ENV=production \
	-e RACK_ENV=production \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	-p 5001:3000 \
	--restart=always \
	portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同版本有的参数配置不太一样，参数调整好以后就可以出现登录页面了。就可以开始操作了。&lt;/p&gt;

&lt;h3 id=&#34;镜像同步:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;镜像同步&lt;/h3&gt;

&lt;p&gt;两种方法： 一段时间同步一次。每次push操作更新一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一段时间同步一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我们登录以后，点击admin选项，会出现红色提示，user portus not exist。这时候你可以先创建portus用户，密码为secrets.yml里填写的密码。这个用户的作用就是同步时候用这个用户当做默认用户同步。&lt;/p&gt;

&lt;p&gt;我们在容器里路径为 /Portus 运行 &lt;code&gt;RAILS_ENV=production CATALOG_CRON=&amp;quot;60.seconds&amp;quot; bundle exec crono&lt;/code&gt; 他就会每隔60秒，用用户portus请求一次registry的 /v2/_catalog这个api查阅所有镜像。我们查看portus 容器日志会收到这个用户发来的请求。&lt;/p&gt;

&lt;p&gt;如果你发现同步失败，请检查是否给了portus admin权限，只有admin权限portus才可以访问所有镜像。&lt;/p&gt;

&lt;p&gt;如果想让这个作为单独容器来同步，可以将命令写成个脚本放到portus镜像里 /crono.sh。然后启动容器时候把命令改成 ./crono.sh就行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次push请求一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是registry 里配置了 notifications，每次push会来向notifications配置的地址发请求。portus server收到请求后来更改数据库。&lt;/p&gt;

&lt;h3 id=&#34;问题:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地配置好以后，想试试域名访问有没有问题，结果改成域名以后一直401。&lt;/p&gt;

&lt;p&gt;后来突然想到，在登录第一次就配置了regitry server信息。应该是这个server名字改变了，所以拒绝了访问。&lt;/p&gt;

&lt;p&gt;修复方法： 直接到数据库的registry表将地址改成域名就行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;push镜像的时候报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error parsing HTTP response: invalid character &#39;&amp;lt;&#39; looking for beginning of value: &amp;quot;&amp;lt;html&amp;gt;\r\n&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;413 Request Entity Too Large&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\r\n&amp;lt;body bgcolor=\&amp;quot;white\&amp;quot;&amp;gt;\r\n&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;413 Request Entity Too Large&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;\r\n&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.9.14&amp;lt;/center&amp;gt;\r\n&amp;lt;/body&amp;gt;\r\n&amp;lt;/html&amp;gt;\r\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题是因为我们使用了http，并配置了nginx，但是默认只有https才允许有basic auth，所以认证失败了。换成https就行。
issue地址：&lt;a href=&#34;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&#34;&gt;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;portus读配置的顺序 配置文件 &amp;gt; -e 参数.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry可以不配置auth并使用portus的，登录portus时候添加registry skip error就可以，但是使用的时候会报很多错误，语言bug，改改代码就ok。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry 的issuer 对应的就是portus/config/FQDN的value，文档没有说明白，坑的一逼。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有api，如果不想直接操作web来创建用户等，就需要自己写方法去操作数据库了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>