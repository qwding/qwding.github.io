<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on QWDing blog</title>
    <link>http://blog.qwding.com/categories/golang/</link>
    <description>Recent content in Golang on QWDing blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jun 2016 19:19:58 +0800</lastBuildDate>
    <atom:link href="http://blog.qwding.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang: change instance address in his method</title>
      <link>http://blog.qwding.com/post/golang_struct_func_changeaddr/</link>
      <pubDate>Wed, 01 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_struct_func_changeaddr/</guid>
      <description>

&lt;h3 id=&#34;前提回顾:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;前提回顾&lt;/h3&gt;

&lt;p&gt;对于结构体中的指针应用，大部分可能知道的是如下两代码的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a *AA) funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a AA) funcB()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;区别在于，我们在funcA内修改a的值，是可以成功的，但是在funcB修改a的值是失败的。&lt;/p&gt;

&lt;p&gt;因为funcA中的a是指针传递，funcB中的a是值传递。这个大家都知道。&lt;/p&gt;

&lt;h3 id=&#34;今天话题:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;今天话题&lt;/h3&gt;

&lt;p&gt;先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type AA struct {
	xyz string
	opq string
}

func (this *AA) Change() {
	b := &amp;amp;AA{xyz: &amp;quot;xyz1&amp;quot;, opq: &amp;quot;opq1&amp;quot;}
	this = b
	fmt.Println(&amp;quot;in this:&amp;quot;, this, &amp;quot;addr:&amp;quot;, &amp;amp;this)
}

func main() {
	a := &amp;amp;AA{xyz: &amp;quot;xyz0&amp;quot;, opq: &amp;quot;opq0&amp;quot;}
	fmt.Println(&amp;quot;before a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)

	a.Change()

	fmt.Println(&amp;quot;after a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么问题来了，请回答一下程序执行过程的三个输出是什么。&lt;/p&gt;

&lt;h3 id=&#34;一开始的想法:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;一开始的想法&lt;/h3&gt;

&lt;p&gt;开始简单认为Change方法是指针传递，那么在里面修改了实例的地址，应该是可以实现的，所以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output1 != output2 == output3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;肯定和预想不一样:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;肯定和预想不一样&lt;/h3&gt;

&lt;p&gt;结果图片如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果： &lt;code&gt;output1  == output3 != output2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;面向对象的编程，在编译的时候，会将类的方法进行一下转换，类似如下：&lt;/p&gt;

&lt;p&gt;A.f() 会转换成 Object.f(A)&lt;/p&gt;

&lt;p&gt;而转换后的函数方法，也分值传递和指针传递。而这时候是值传递，导致你无论怎么修改A的地址，在函数外面都不会改变。&lt;/p&gt;

&lt;h3 id=&#34;再清晰一点:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;再清晰一点&lt;/h3&gt;

&lt;p&gt;可以思考一下堆栈的分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr_pic1.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;手拙，用excel画了个堆栈图&lt;/p&gt;

&lt;p&gt;在执行Chang()时，会生成变量this，这个变量this里存的就是传进来值的地址，main函数里的a变量里存的也是这个地址。
所以修改值得时候，两边是互通的。&lt;/p&gt;

&lt;p&gt;但是，我们Chang()函数是修改的this的值，也就是将 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff00 (a_value)&lt;/code&gt; 改成了 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff10(b_value)&lt;/code&gt;  可是在main函数里面a的值还是没有变。所以output3，还是a指向的地址里的值。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>