<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>QWDing blog</title>
    <link>http://blog.qwding.com/</link>
    <description>Recent content on QWDing blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Aug 2016 23:53:36 +0800</lastBuildDate>
    <atom:link href="http://blog.qwding.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Evernote vs youdao</title>
      <link>http://blog.qwding.com/post/evernote_vs_youdao/</link>
      <pubDate>Sun, 28 Aug 2016 23:53:36 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/evernote_vs_youdao/</guid>
      <description>

&lt;h1 id=&#34;evernote:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;Evernote&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;之前一直用evernote，也没发现什么优点，本人流量一直没有超过60M/月限制，所以基本来说只用云笔记部分&lt;/li&gt;
&lt;li&gt;编辑功能，不得不吐槽，我除了会在文本前面加点或者用tab分级外，其他什么编辑功能都不会，甚至有时候被他的带格式粘贴搞迷糊好半天&lt;/li&gt;
&lt;li&gt;编辑工具栏，默认的居然是黑色，字体已经是黑色了，你这个黑色有毛用啊。调个颜色半天都有次还调不出来。&lt;/li&gt;
&lt;li&gt;前几天有出现了限制2台硬件绑定。纳尼？？？弃用弃用，没商量&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;有道云笔记:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;有道云笔记&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;因为国内的好像也就是有道了，其他的有些偏向团队，有些偏向会议之类的&lt;/li&gt;
&lt;li&gt;发现有道的分级比Evernote爽一万倍，虽然功能简单，但是从之前那么蛋疼转过来爽了真的不是一点半点&lt;/li&gt;
&lt;li&gt;发现有道V2.1.0版本居然可以直接将pdf等直接传到目录下直接观看，保存文档，整理笔记更近一步啊！&lt;/li&gt;
&lt;li&gt;有道居然可以用markdown，一些用markdown写的文档直接保存就ok了&lt;/li&gt;
&lt;li&gt;有道有个缺点，就是一次我只圈中了一小部分文档复制，粘贴的时候居然带了整行的格式，日了狗了，恰恰粘贴的是密码，而且是那种特殊密码，以为是密码问题了，搞了好久&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;vs:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;VS&lt;/h1&gt;

&lt;p&gt;查看两者之后是不是感觉有道云笔记完爆了Evernote，但是，还别急&lt;/p&gt;

&lt;p&gt;用了一阵后，发现&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有道居然超级吃内存，我8G的mac，刚开始用的时候，转移了部分笔记，已经吃到了800M，今天有略加了几个pdf，已经超过1.1G了，笔记容量加起来都不过几十M啊，简直可怕！！！相比之下，evernote一般都保持在200M左右，还是比较安静的，从来不会因为内存着急。&lt;/li&gt;
&lt;li&gt;据他人说，有道想修改附件的话，必须下载下来，编辑后再传上去才行，但是evernote直接可以在线编辑&lt;/li&gt;
&lt;li&gt;有道虽然有markdown，但是不能搜索，原因当然是显示的时候已经转成html，而html并不支持搜索。可是你也可以在md原文搜索啊！但是并没有，也就是说我写了md，就丧失了搜索功能。而我认为在云笔记这么庞大的东西面前，搜索才是最重要的，类似于mac的alfred，快速定位才行。相比evernote搜索用着还是可以接受的，当前目录和全局搜索两选项，而有道只能在当前目录下，如果想搜全局还有用鼠标在点下全局文件夹，恰恰我用的最多的是全局搜索。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;总结:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;总的来说，两个都不想用&lt;/p&gt;

&lt;p&gt;Evernote编辑功能不爽，还有设备限制(本人恰巧需要三台)&lt;/p&gt;

&lt;p&gt;有道云笔记太吃内存，如果不吃这么多内存基本就用了，但是吃这么多内存搞得我8G都不够用了&lt;/p&gt;

&lt;p&gt;基本想找一款更好的云笔记软件，也希望获得推荐&lt;/p&gt;

&lt;p&gt;使用体验持续更新&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go map,slice,array 遍历性能测试 </title>
      <link>http://blog.qwding.com/post/gotest_map_array_slice/</link>
      <pubDate>Mon, 27 Jun 2016 14:28:44 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/gotest_map_array_slice/</guid>
      <description>

&lt;h1 id=&#34;就是随便试试:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#就是随便试试&lt;/h1&gt;

&lt;p&gt;听说goalng的map和slice的遍历性能差的不是一点半点，于是没事写个benchmark来玩玩
代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package testings

import(
	&amp;quot;testing&amp;quot;
	&amp;quot;strconv&amp;quot;
)

var length = 1000
var maps map[string]string
var slices []string
var arrays [1000]string

func init(){
	maps = make(map[string]string,length)
	slices = make([]string,length)
	for i:=0;i&amp;lt;length;i++{
		maps[strconv.Itoa(i)] = &amp;quot;abc&amp;quot;
		slices[i] = &amp;quot;abc&amp;quot;
		arrays[i] = &amp;quot;abc&amp;quot;
	}

}


func BenchmarkIterateMap(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range maps{
		}
	}
}

func BenchmarkIterateSlices(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range slices{
		}
	}
}

func BenchmarkIterateArrays(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range arrays{
		}
	}
}

func BenchmarkIterateMapF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range maps{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range slices{
			_ = k
		}
	}
}

func BenchmarkIterateArraysF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range arrays{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_ = slices[j]
		}
	}
}

func BenchmarkIterateArraysFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_= arrays[j]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试结果:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#测试结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;➜  testings git:(master) ✗ go test -bench=. iterate_map_vs_slice_vs_array_test.go
testing: warning: no tests to run
PASS
BenchmarkIterateMap-4      	  100000	     20544 ns/op
BenchmarkIterateSlices-4   	 5000000	       368 ns/op
BenchmarkIterateArrays-4   	 5000000	       371 ns/op
BenchmarkIterateMapF-4     	  100000	     21685 ns/op
BenchmarkIterateSlicesF-4  	 2000000	       812 ns/op
BenchmarkIterateArraysF-4  	 1000000	      1036 ns/op
BenchmarkIterateSlicesFor-4	 1000000	      1199 ns/op
BenchmarkIterateArraysFor-4	 1000000	      1024 ns/op
ok  	command-line-arguments	14.858s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;看数据:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#看数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;先看前面三个方法，只是遍历，没有应用数据，大小都是1000，map 居然是slice和array的57倍之多。&lt;/li&gt;
&lt;li&gt;接下来三个方法是应用到了数据，map性能损耗基本没有增多多少，但是slice和array却增多一倍多（还不了解为什么）&lt;/li&gt;
&lt;li&gt;后面两个表明 array的按index取和range取性能不变，但是slice是有差距的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数据不是固定的:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#数据不是固定的&lt;/h3&gt;

&lt;p&gt;将slice和map的大小分布调成10，100，1000，10000，得出的性能比，map/slice是不固定的，也没有发现什么规律(测试不够充分)，但是一般都在将近30倍以上。但是可以得出遍历性能确实差很多。&lt;/p&gt;

&lt;h3 id=&#34;slice-不同情况性能差距也比较大:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#slice 不同情况性能差距也比较大&lt;/h3&gt;

&lt;h3 id=&#34;遗留问题:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#遗留问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;slice 为什么只遍历和取到数据还有一倍多的性能损耗&lt;/li&gt;
&lt;li&gt;slice 的index取数和range取数性能也有差距&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>shell execute mongo/mysql which start by docker.</title>
      <link>http://blog.qwding.com/post/shell_exec_db/</link>
      <pubDate>Tue, 07 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/shell_exec_db/</guid>
      <description>

&lt;h1 id=&#34;问题初衷:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#问题初衷&lt;/h1&gt;

&lt;p&gt;打算一键部署带权限验证的mongo。但是docker hub官方镜像创建mongo步骤为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name mongodb -d -p 27017:27017 mongo:3.3 --auth
docker exec -it mongodb mongo admin
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打算将其做成脚本&lt;/p&gt;

&lt;h1 id=&#34;用shell实现:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#用shell实现&lt;/h1&gt;

&lt;p&gt;经过查阅，发现shell的 &amp;lt;&amp;lt;EOF 可以实现，查阅资料 &lt;a href=&#34;http://my.oschina.net/u/1032146/blog/146941&#34;&gt;http://my.oschina.net/u/1032146/blog/146941&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;应该可以实现,于是写了脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mongo 启动的容器内执行脚本，成功！&lt;/p&gt;

&lt;h1 id=&#34;直接写脚本启动容器-error:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#直接写脚本启动容器(error)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;!/bin/bash
docker run --name mongodb -d -p 27017:27017 dhub.yunpro.cn/cloud/mongo:3.3 --auth
sleep 1
docker exec -it mongodb mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sleep 1秒是保证mongo起来后才执行exec。&lt;/p&gt;

&lt;p&gt;但是会报错 &lt;code&gt;cannot enable tty mode on non tty input&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为什么报错呢？容器内运行却没问题&lt;/p&gt;

&lt;p&gt;一开始认为是不是docker exec 后面接命令执行 &amp;lt;&amp;lt; EOF 识别不了？想了想不是这么回事&lt;/p&gt;

&lt;p&gt;后来仔细思考了报错，只不过说不能启动一个伪终端，我又想到docker的 i 和 t 参数分别表示输入和伪终端，是不是根本就不需要伪终端啊，于是将 t 参数去掉&lt;/p&gt;

&lt;p&gt;执行成功！&lt;/p&gt;

&lt;h1 id=&#34;总结:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#总结&lt;/h1&gt;

&lt;p&gt;对shell并不熟悉，也不太深入了解伪终端，但是像这种启动mongo的方法，也类似于启动mysql，执行mysql句子类似，还是应了解每个参数作用&lt;/p&gt;

&lt;h1 id=&#34;附上改后脚本-ok:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;附上改后脚本(ok)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
docker run --name mongodb -d -p 27017:27017 dhub.yunpro.cn/cloud/mongo:3.3 --auth
sleep 1

docker exec -i mongodb mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>golang: change instance address in his method</title>
      <link>http://blog.qwding.com/post/golang_struct_func_changeaddr/</link>
      <pubDate>Wed, 01 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/golang_struct_func_changeaddr/</guid>
      <description>

&lt;h3 id=&#34;前提回顾:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;前提回顾&lt;/h3&gt;

&lt;p&gt;对于结构体中的指针应用，大部分可能知道的是如下两代码的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a *AA) funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a AA) funcB()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;区别在于，我们在funcA内修改a的值，是可以成功的，但是在funcB修改a的值是失败的。&lt;/p&gt;

&lt;p&gt;因为funcA中的a是指针传递，funcB中的a是值传递。这个大家都知道。&lt;/p&gt;

&lt;h3 id=&#34;今天话题:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;今天话题&lt;/h3&gt;

&lt;p&gt;先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type AA struct {
	xyz string
	opq string
}

func (this *AA) Change() {
	b := &amp;amp;AA{xyz: &amp;quot;xyz1&amp;quot;, opq: &amp;quot;opq1&amp;quot;}
	this = b
	fmt.Println(&amp;quot;in this:&amp;quot;, this, &amp;quot;addr:&amp;quot;, &amp;amp;this)
}

func main() {
	a := &amp;amp;AA{xyz: &amp;quot;xyz0&amp;quot;, opq: &amp;quot;opq0&amp;quot;}
	fmt.Println(&amp;quot;before a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)

	a.Change()

	fmt.Println(&amp;quot;after a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么问题来了，请回答一下程序执行过程的三个输出是什么。&lt;/p&gt;

&lt;h3 id=&#34;一开始的想法:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;一开始的想法&lt;/h3&gt;

&lt;p&gt;开始简单认为Change方法是指针传递，那么在里面修改了实例的地址，应该是可以实现的，所以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output1 != output2 == output3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;肯定和预想不一样:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;肯定和预想不一样&lt;/h3&gt;

&lt;p&gt;结果图片如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果： &lt;code&gt;output1  == output3 != output2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;面向对象的编程，在编译的时候，会将类的方法进行一下转换，类似如下：&lt;/p&gt;

&lt;p&gt;A.f() 会转换成 Object.f(A)&lt;/p&gt;

&lt;p&gt;而转换后的函数方法，也分值传递和指针传递。而这时候是值传递，导致你无论怎么修改A的地址，在函数外面都不会改变。&lt;/p&gt;

&lt;h3 id=&#34;再清晰一点:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;再清晰一点&lt;/h3&gt;

&lt;p&gt;可以思考一下堆栈的分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.qwding.com/img/chang_addr_pic1.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;手拙，用excel画了个堆栈图&lt;/p&gt;

&lt;p&gt;在执行Chang()时，会生成变量this，这个变量this里存的就是传进来值的地址，main函数里的a变量里存的也是这个地址。
所以修改值得时候，两边是互通的。&lt;/p&gt;

&lt;p&gt;但是，我们Chang()函数是修改的this的值，也就是将 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff00 (a_value)&lt;/code&gt; 改成了 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff10(b_value)&lt;/code&gt;  可是在main函数里面a的值还是没有变。所以output3，还是a指向的地址里的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install portus by docker and configration read.</title>
      <link>http://blog.qwding.com/post/portus/</link>
      <pubDate>Wed, 20 Apr 2016 11:48:19 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/portus/</guid>
      <description>

&lt;h3 id=&#34;一般形式:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;一般形式&lt;/h3&gt;

&lt;p&gt;在官方文档，或者百度谷歌，搜到的portus一般都是compose形式搭建，这样好处是操作无脑&lt;/p&gt;

&lt;p&gt;但是一般情况下我们肯定是自己要更灵活一些的，肯定用docker容器形式更舒服一点。可是去dockerhub一搜，各种版本的镜像，查看dockerfile很多人都自己加了一些内容，对于不会ruby的人来说，并不知道那些操作都说干啥的。&lt;/p&gt;

&lt;h3 id=&#34;自己研究研究:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;自己研究研究&lt;/h3&gt;

&lt;p&gt;github master分支上有dockerfile，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM library/rails:4.2.2
MAINTAINER Flavio Castelli &amp;lt;fcastelli@suse.com&amp;gt;

ENV COMPOSE=1
EXPOSE 3000

WORKDIR /portus
COPY Gemfile* ./
RUN bundle install --retry=3

# Install phantomjs, this is required for testing and development purposes
# There are no official deb packages for it, hence we built it inside of the
# open build service.
RUN echo &amp;quot;deb http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/ ./&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list
RUN wget http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/Release.key &amp;amp;&amp;amp; \
  apt-key add Release.key &amp;amp;&amp;amp; \
  rm Release.key
RUN apt-get update &amp;amp;&amp;amp; \
    apt-get install -y --no-install-recommends phantomjs &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*

ADD . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是直接用那个dockerfile直接build一个镜像。参考别人给出的一些docker run参数启动，并成功了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -e RAILS_ENV=production \
	-e RACK_ENV=production \
	-e PORTUS_SECRET_KEY_BASE=secret-goes-here \
	-e PORTUS_KEY_PATH=/certs/server-key.pem \
	-e PORTUS_PASSWORD=portuspw \
	-e PORTUS_CHECK_SSL_USAGE_ENABLED=false \
	-e PORTUS_MACHINE_FQDN_VALUE=192.168.56.101 \
	-e PORTUS_PRODUCTION_HOST=192.168.56.101 \
	-e PORTUS_PRODUCTION_USERNAME=portus \
	-e PORTUS_PRODUCTION_PASSWORD=portus \
	-e PORTUS_PRODUCTION_DATABASE=portus \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	--restart=always \
	-p 5001:3000 portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下这些参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PORTUS_SECRET_KEY_BASE 是rails 4.0以后出的一个web安全参数，一般要rake secret生成一个很长很长的随机串，发现随意写个串也无妨。&lt;/li&gt;
&lt;li&gt;PORTUS_KEY_PATH 猜测是对应registry给出那个crt的。&lt;/li&gt;
&lt;li&gt;PORTUS_PASSWORD 这个参数有意思。在你创建好portus后，需要创建一个用户叫 portus。密码就是这个密码。这个用户的目的是为了同步镜像用的。（之后说）&lt;/li&gt;
&lt;li&gt;PORTUS_CHECK_SSL_USAGE_ENABLED 因为我没有官方签发证书，所以用http，如果https，在registry的notifications时候会发不过去。&lt;/li&gt;
&lt;li&gt;PORTUS_MACHINE_FQDN_VALUE 就是你的portus要配置的域名。&lt;/li&gt;
&lt;li&gt;PORTUS_PRODUCTION_HOST，PORTUS_PRODUCTION_USERNAME，PORTUS_PRODUCTION_PASSWORD，PORTUS_PRODUCTION_DATABASE这几个就是数据库的地址，帐号，密码，数据库&lt;/li&gt;
&lt;li&gt;puma -b tcp://0.0.0.0:3000 -w 3 是执行的CMD，试了一下，这个镜像默认是什么都不执行的，所以启动可以添加这个命令，如果不想每次加可以在dockerfile里加上CMD.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简化一下:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;简化一下&lt;/h3&gt;

&lt;p&gt;显然，如上启动方式跟了一大堆参数是很烦的，也不是你想的。当然那就把它们放到配置文件里。&lt;/p&gt;

&lt;p&gt;主要有三个配置文件都放在了 Portus/config 文件夹下。分别为 config.yml, database.yml, secrets.yml&lt;/p&gt;

&lt;p&gt;将几个env变量都可以配置到文件的production里。&lt;/p&gt;

&lt;p&gt;值得注意的是，PORTUS_MACHINE_FQDN_VALUE这个变量在2.0.3版本里是放在了secrets.yml 里，但是如果你用的是portus的master分支，最新的代码是放在config.yml里的。一坑。&lt;/p&gt;

&lt;p&gt;所以启动方式可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d \
	-e RAILS_ENV=production \
	-e RACK_ENV=production \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	-p 5001:3000 \
	--restart=always \
	portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同版本有的参数配置不太一样，参数调整好以后就可以出现登录页面了。就可以开始操作了。&lt;/p&gt;

&lt;h3 id=&#34;镜像同步:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;镜像同步&lt;/h3&gt;

&lt;p&gt;两种方法： 一段时间同步一次。每次push操作更新一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一段时间同步一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我们登录以后，点击admin选项，会出现红色提示，user portus not exist。这时候你可以先创建portus用户，密码为secrets.yml里填写的密码。这个用户的作用就是同步时候用这个用户当做默认用户同步。&lt;/p&gt;

&lt;p&gt;我们在容器里路径为 /Portus 运行 &lt;code&gt;RAILS_ENV=production CATALOG_CRON=&amp;quot;60.seconds&amp;quot; bundle exec crono&lt;/code&gt; 他就会每隔60秒，用用户portus请求一次registry的 /v2/_catalog这个api查阅所有镜像。我们查看portus 容器日志会收到这个用户发来的请求。&lt;/p&gt;

&lt;p&gt;如果你发现同步失败，请检查是否给了portus admin权限，只有admin权限portus才可以访问所有镜像。&lt;/p&gt;

&lt;p&gt;如果想让这个作为单独容器来同步，可以将命令写成个脚本放到portus镜像里 /crono.sh。然后启动容器时候把命令改成 ./crono.sh就行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次push请求一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是registry 里配置了 notifications，每次push会来向notifications配置的地址发请求。portus server收到请求后来更改数据库。&lt;/p&gt;

&lt;h3 id=&#34;问题:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地配置好以后，想试试域名访问有没有问题，结果改成域名以后一直401。&lt;/p&gt;

&lt;p&gt;后来突然想到，在登录第一次就配置了regitry server信息。应该是这个server名字改变了，所以拒绝了访问。&lt;/p&gt;

&lt;p&gt;修复方法： 直接到数据库的registry表将地址改成域名就行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;push镜像的时候报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error parsing HTTP response: invalid character &#39;&amp;lt;&#39; looking for beginning of value: &amp;quot;&amp;lt;html&amp;gt;\r\n&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;413 Request Entity Too Large&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\r\n&amp;lt;body bgcolor=\&amp;quot;white\&amp;quot;&amp;gt;\r\n&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;413 Request Entity Too Large&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;\r\n&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.9.14&amp;lt;/center&amp;gt;\r\n&amp;lt;/body&amp;gt;\r\n&amp;lt;/html&amp;gt;\r\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题是因为我们使用了http，并配置了nginx，但是默认只有https才允许有basic auth，所以认证失败了。换成https就行。
issue地址：&lt;a href=&#34;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&#34;&gt;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;portus读配置的顺序 配置文件 &amp;gt; -e 参数.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry可以不配置auth并使用portus的，登录portus时候添加registry skip error就可以，但是使用的时候会报很多错误，语言bug，改改代码就ok。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry 的issuer 对应的就是portus/config/FQDN的value，文档没有说明白，坑的一逼。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有api，如果不想直接操作web来创建用户等，就需要自己写方法去操作数据库了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>温暖的木屋</title>
      <link>http://blog.qwding.com/relax/warm_house/</link>
      <pubDate>Thu, 14 Apr 2016 18:18:02 +0800</pubDate>
      
      <guid>http://blog.qwding.com/relax/warm_house/</guid>
      <description>&lt;p&gt;在v2ex上发现了一个小游戏，据说专门写代码时候在后台挂着的，于是也玩了一下。根本停不下来。&lt;/p&gt;

&lt;p&gt;链接：&lt;a href=&#34;http://g.miaowu.asia/index.php&#34;&gt;http://g.miaowu.asia/index.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直接在线自动存档了。&lt;/p&gt;

&lt;p&gt;讲的大概就是从一个小黑屋发展成大村庄的故事，最后走向了外太空~~~&lt;/p&gt;

&lt;p&gt;整个游戏概述：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;就是一直挂机，收集资源，有了资源可以发展，发展到一定程度，出现新资源，可以提升自己的战斗力。&lt;/li&gt;
&lt;li&gt;之后买得起罗盘就可以开始探索，探索时候要注意携带的水量和腊肉量，一旦任意耗光，就死掉了，回家继续发展。&lt;/li&gt;
&lt;li&gt;探索途中会遇到野怪，控制好血量不要死掉就行，装备的话武器一样带一个就行。剩下都是腊肉都无所谓了。探索洞穴需要火把，带3个足够了。&lt;/li&gt;
&lt;li&gt;一定控制好资源够回家的水和肉。&lt;/li&gt;
&lt;li&gt;探索到一定程度就可以上天了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽说是挂机游戏，但是探索时候真心还是不挂机&amp;hellip;&lt;/p&gt;

&lt;p&gt;而且这是好几年前的游戏了，有开源代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;祝玩的愉快~&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo vs hexo</title>
      <link>http://blog.qwding.com/post/hugo_vs_hexo/</link>
      <pubDate>Fri, 08 Apr 2016 18:51:19 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/hugo_vs_hexo/</guid>
      <description>

&lt;h3 id=&#34;hugo-和-hexo-对比:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;hugo 和 hexo 对比&lt;/h3&gt;

&lt;p&gt;主要是查阅了一下很多人经验，并汇总了一下对比结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                     hexo                           hugo
速度                  快                           特别快
主题           几大主题基础上延伸,总量更多     很多,良好主题生态圈
安装及更新       更新容易有坑，因为依赖包       一个binary,安装更新快
评论系统           支持disqus等                   支持disqus等
应用方面          博客适应性更强	             非博客适应性更强
文档              有中文文档                    文档超详细，中文不全
功能            分类,tag,多语言,i18n       分类,tag,series,wight,多语言

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为本身更喜欢golang，所以选择了hugo&lt;/p&gt;

&lt;h3 id=&#34;分享一下查阅的资料:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;分享一下查阅的资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://beebom.com/2015/04/best-static-site-generators&#34;&gt;十种静态页面生成工具&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hexo.io/&#34;&gt;hexo 文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hexo.io/zh-cn/docs/&#34;&gt;hexo 中文文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/465830080ea9&#34;&gt;hexo 一篇比较好的使用文章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.gohugo.io/overview/quickstart/&#34;&gt;hugo 文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.gohugo.org/doc&#34;&gt;hugo 中文文档&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;hugo 主题&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gitlab-pages:f5f80bcd59ef9d4f36dd6010f161a624&#34;&gt;gitlab pages&lt;/h3&gt;

&lt;p&gt;gitlab 8.3以后也出了github pages的功能，但只限gitlab-ee版本，需要付费&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://doc.gitlab.com/omnibus/docker/&#34;&gt;gitlab-ee docker安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://doc.gitlab.com/ee/pages/README.html&#34;&gt;gitlab pages使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>矫情</title>
      <link>http://blog.qwding.com/persional/main/</link>
      <pubDate>Fri, 08 Apr 2016 12:06:31 +0800</pubDate>
      
      <guid>http://blog.qwding.com/persional/main/</guid>
      <description>

&lt;h3 id=&#34;贱人就是矫情:379caad01b6ea305187be199bcac1370&#34;&gt;贱人就是矫情&lt;/h3&gt;

&lt;p&gt;没事矫情一下，在这里写一些与技术无关的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一个开始</title>
      <link>http://blog.qwding.com/post/main/</link>
      <pubDate>Fri, 08 Apr 2016 11:57:57 +0800</pubDate>
      
      <guid>http://blog.qwding.com/post/main/</guid>
      <description>

&lt;h3 id=&#34;写点博客总是好的:379caad01b6ea305187be199bcac1370&#34;&gt;写点博客总是好的&lt;/h3&gt;

&lt;p&gt;长点心，写点博客，少打游戏。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://blog.qwding.com/about/</link>
      <pubDate>Fri, 01 Apr 2016 18:18:07 +0800</pubDate>
      
      <guid>http://blog.qwding.com/about/</guid>
      <description>

&lt;h3 id=&#34;过山车式的履历:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;过山车式的履历&lt;/h3&gt;

&lt;p&gt;一开始在高大上的double e做测试，半年后实在忍受不了傻逼式的点点点，担心式的写英文邮件和各种测试用例的文字游戏。遂放弃了，更可以说是逃避了。&lt;/p&gt;

&lt;p&gt;转而做golang开发，语法简洁，开发迅速，性能强大等等让我很喜欢他。并很感谢我上个公司给了我很好的机会和平台，一年内得到很多锻炼。&lt;/p&gt;

&lt;p&gt;但是懒癌不能忍受周末加班还是让我跳了槽，来到了现公司。 却发现有种被忽悠来的感觉。&lt;/p&gt;

&lt;p&gt;与其来说是来做后台开发，不如说是来做ops的&amp;hellip;&lt;/p&gt;

&lt;p&gt;好吧！跨度好大。鉴于公司地理和上班制度以及拥有的并发量还是忍了。&lt;/p&gt;

&lt;h3 id=&#34;懒癌晚期:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;懒癌晚期&lt;/h3&gt;

&lt;p&gt;都说程序员呆板，技术宅，爱加班。我发现我一样不占。&lt;/p&gt;

&lt;p&gt;我不仅不爱加班，更不是技术宅。&lt;/p&gt;

&lt;p&gt;一有时间，先想到的是玩玩玩。并不会在家写代码研究东西&amp;hellip;&lt;/p&gt;

&lt;p&gt;主要还是玩性太大吧。&lt;/p&gt;

&lt;h3 id=&#34;id:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;ID&lt;/h3&gt;

&lt;p&gt;我在网易魔兽官方对战平台打dota的id叫 牛逼ID 和 卡拉赞毕业&lt;/p&gt;

&lt;p&gt;很好记，如果有有人看到打个招呼，玩的开心，被人打招呼玩的还是比较亲的~~~&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>