<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on QWDing blog</title>
    <link>http://qwding.github.io/post/</link>
    <description>Recent content in Posts on QWDing blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Aug 2017 14:33:08 +0800</lastBuildDate>
    <atom:link href="http://qwding.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Waiting a new job</title>
      <link>http://qwding.github.io/post/find_job/</link>
      <pubDate>Fri, 04 Aug 2017 14:33:08 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/find_job/</guid>
      <description>

&lt;h1 id=&#34;公司快黄了-开始找工作:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;公司快黄了，开始找工作&lt;/h1&gt;

&lt;p&gt;在7月末，8月初，本来也并不是找工作的黄金时期来找工作，也是因为公司快黄了，该走了。&lt;/p&gt;

&lt;p&gt;等出去面试后感觉，并不是很少人在跳槽，有的公司的资历老点的人整天都在面试，工作都要加班到后半夜，感觉也是不容易。&lt;/p&gt;

&lt;h1 id=&#34;聊聊hr的坑:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;聊聊HR的坑&lt;/h1&gt;

&lt;p&gt;天真的我，以为实话实说并没有什么问题。于是在第一周的时候，hr会问，你为什么从前两家离职，我说上一家创业公司内部矛盾比较多，上下层有点脱节。&lt;/p&gt;

&lt;p&gt;可谓是说了老东家的坏话，这TMD，只能说：我是傻逼！&lt;/p&gt;

&lt;p&gt;说老东家坏话简直是一大禁忌，在周末的某个忧虑的晚上，突然深深感受到自己的傻逼，于是在接下来的面试，我都是说公司搬家，上班太远等等为借口了，效果还不错，感觉和hr应该没有聊的什么太大问题。&lt;/p&gt;

&lt;h1 id=&#34;技术短板:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;技术短板&lt;/h1&gt;

&lt;p&gt;其实面试的每家公司，基本都可以面到最后一面，但是给offer的寥寥，为什么？！&lt;/p&gt;

&lt;p&gt;总结了一下无非几点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有大公司经验，其实我并不认为去大公司怎么怎么好，相反可能了解的会更窄；但是这时候发现，却是必不可少的，很多公司更注重你之前的环境，大公司那种内涵吧，亦或许是 “这家伙已经过了大公司的面试，应该还是挺牛逼的”。&lt;/li&gt;
&lt;li&gt;没有高并发和分布式经验。高并发指的啥，有几个公司可以说自己的量集很大是高并发，并且碰到很难解决的问题呢。即使是像抢购手机这样的高并发量，其实了解背后，也都是很简单粗暴的方式解决，并没有说你通过牛逼的代码就可以解决。但是人家就是要看你有没有这个经验。&lt;/li&gt;
&lt;li&gt;数据库需求，有几个大厂，貌似对数据库要求比较高，像我这种可能没有真做过读写分离，数据库量级没有那么高，被问到一些mysql的尖酸问题，直接gg。&lt;/li&gt;
&lt;li&gt;钱要的有点过，人家并不着急要人，这才是根本原因&amp;hellip;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;这些年到底做了什么:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;这些年到底做了什么&lt;/h1&gt;

&lt;p&gt;看到上面几点，感觉这几年工作到底做了啥，是不是天天上班晃悠了&lt;/p&gt;

&lt;p&gt;有点心酸，谁乐意晃悠到现在感觉找工作又很尴尬呢。找工作真的是一件很看运气的事，在现在公司我工做也是很认真，但是真正的工作内容可能并不适合我现在要找的方向，并不适合。&lt;/p&gt;

&lt;p&gt;也许我在这里一直在擦屁股或者去擦屁股的路上（戴维营欢迎你 2333）。&lt;/p&gt;

&lt;h1 id=&#34;说一说碰到的主要问题吧:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;说一说碰到的主要问题吧&lt;/h1&gt;

&lt;h3 id=&#34;golang:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;golang&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;gc实现，主要是三色标记过程&lt;/li&gt;
&lt;li&gt;slice，map实现原理&lt;/li&gt;
&lt;li&gt;golang的锁应用&lt;/li&gt;
&lt;li&gt;chan的应用，sync.waitGroup，select 的timeout导致cpu激增。&lt;/li&gt;
&lt;li&gt;var tmp interface{} = nil;  tmp == nil 返回值（答案是false)&lt;/li&gt;
&lt;li&gt;怎么优化gc停顿时间&lt;/li&gt;
&lt;li&gt;pprof怎么调优&lt;/li&gt;
&lt;li&gt;阅读过哪些golang写的源码： k8s，docker，beego等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实遇到golang的问题，我一般还是都可以应对自如的，基本没啥问题&lt;/p&gt;

&lt;h3 id=&#34;几个值得学习的问题:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;几个值得学习的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;系统设计，比如说有个活动，设计一套系统：匹配对手，出石头剪子布，胜者可抽奖。设计这么套系统。
主要注意的点： 匹配对手，比赛出拳，抽奖，奖池。最主要考察的是，这是一个分布式高并发的系统。&lt;/li&gt;
&lt;li&gt;算法，这个不用多说了，多刷题吧，一般不会太难，把递归搞通了可以处理大部分面试的难度。&lt;/li&gt;
&lt;li&gt;linux 命令，一般awk，ss -s，sed等等吧，但是sed我是真用的不多，碰到gg。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;弄得好不如白话的好:b16d4ecb05493851fce54dc3060a3d5e&#34;&gt;弄得好不如白话的好&lt;/h1&gt;

&lt;p&gt;即使不是你做的，你可以白话成你做的&lt;/p&gt;

&lt;p&gt;即使不牛逼，也可以白话的很牛逼&lt;/p&gt;

&lt;p&gt;即使问题并不难，但是也可以白话好解决问题过程&lt;/p&gt;

&lt;p&gt;其实面试还是一个心理挑战，你把面试官忽悠明白，让他认为你行就可以，而能力是其次的，你做事情的能力不如你白话的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker golang 今天遇到的坑 吐槽</title>
      <link>http://qwding.github.io/post/4_24_keng/</link>
      <pubDate>Mon, 24 Apr 2017 19:43:29 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/4_24_keng/</guid>
      <description>

&lt;h1 id=&#34;过程是这样的:3d134ffadfa460621f0e6e5b974fab00&#34;&gt;过程是这样的&lt;/h1&gt;

&lt;p&gt;因需求，写了一个小小的golang项目，但是在打包docker封装时候遇到了很奇怪的问题。&lt;/p&gt;

&lt;p&gt;首先是我在linux编译好的程序，想打进alpine镜像（在我本地mac电脑做），发现打进去之后运行不了程序，报/bin/bash : binary not found . google一下，有说版本的，也有说别的的，但是关键是，这个镜像当时打包其他golang binary都没有问题。&lt;/p&gt;

&lt;p&gt;然后我在我编译那台机尝试打包镜像，pull一个alpine镜像。bug&amp;hellip; 跟docker启动device map有关&amp;hellip;. 为了不影响其他应用，忍了把，我不用这个机器了行吧&lt;/p&gt;

&lt;p&gt;返回用mac，无意间发现。。。我用mac交叉编译的程序，打到镜像里，居然可以跑，差异加惊喜。不管原因了，能跑就行。&lt;/p&gt;

&lt;p&gt;我写的项目里用到了golang1.8的新功能plugin。跑那个模块时候居然报错，plugin：not implement. 懵逼ing&amp;hellip; 之前跑都没有问题，为啥交叉编译以后再容器里那个模块就失效了！还报这个错。&lt;/p&gt;

&lt;p&gt;到目前为止，感觉是两种环境，两个错误。日了狗一样&amp;hellip;&lt;/p&gt;

&lt;p&gt;最起码交叉编译那种有错误可查，翻了google没有人报这个错误啊！是没有这个错误。懵逼。。。&lt;/p&gt;

&lt;p&gt;查源码吧。。。进到plugin目录，很开心看到只有3个文件，很开心看到文件都很短。什么？ 很短？阅读以下。 这TM就结束了？逻辑呢？ google一下。原来plugin因为bug这个版本取消了。用1.8beta可以用&amp;hellip;. 好吧。下1.8吧。 官网&amp;hellip; 没有&amp;hellip; 没有beta版本。。。去golangtc.com下载吧。 我去&amp;hellip; 超级慢，慢可以忍，最重要的是，下到一半，用chrome下载会挺掉，直接结束了有木有。好的，那我们就找个服务器curl吧，也跟拉便便一样慢，放那里慢慢下去吧。&lt;/p&gt;

&lt;p&gt;然后非常不爽的我还换了几个alpine版本，均失败。后来我妥协了，下了一个ubuntu。麻蛋，一下就好使了，我好无语&amp;hellip;&lt;/p&gt;

&lt;p&gt;仅以此文吐槽下，居然忙了一下午&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ldconfig</title>
      <link>http://qwding.github.io/post/ldconf/</link>
      <pubDate>Wed, 22 Feb 2017 18:11:04 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/ldconf/</guid>
      <description>

&lt;h3 id=&#34;事情起因:41d79fbd6af245a7aa6bb03b7d578a78&#34;&gt;事情起因&lt;/h3&gt;

&lt;p&gt;最近接了个C++项目，结果编译完放到服务器上会报动态库版本不对，之后又是一个系统库不对，我粗暴的将CentOS 7(之前不知道系统是7&amp;hellip;不然打死也不这么干啊) 的/lib64/libc.so.6 直接拷贝到了CentOS 6.5系统上，灾难发生了&amp;hellip;.&lt;/p&gt;

&lt;p&gt;所有命令用不了，傻逼了&amp;hellip; 恰好那个服务器正跑着一个pv 几百万的项目，顿时压力山大&lt;/p&gt;

&lt;p&gt;绝大部分命令都用不了，ls 命令都用不了了，本想将软链换回去，ln 不好使，怎么办！&lt;/p&gt;

&lt;p&gt;后来查阅到命令ldconfig，专门管理动态库的，发现这个命令可以运行诶（哭笑脸）。&lt;/p&gt;

&lt;p&gt;在查阅其参数，发现只有一个-l貌似可以用到，可是大部分博客都是这么写的： -l  Manually link individual libraries. 并没有看到列子（哭笑脸）&lt;/p&gt;

&lt;p&gt;抱着死马当活马医的心态试用如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ldconfig -l /lib64/libc.so.6 /lib64/libc-2.12.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;居然好使了，福大命大！
后来检查发现，貌似这个命令只是临时更改软链，想永久改还是需要修改文件的。&lt;/p&gt;

&lt;h3 id=&#34;ldconfig:41d79fbd6af245a7aa6bb03b7d578a78&#34;&gt;ldconfig&lt;/h3&gt;

&lt;p&gt;写的感觉不错的链接：&lt;a href=&#34;http://blog.csdn.net/unix21/article/details/12119861&#34;&gt;http://blog.csdn.net/unix21/article/details/12119861&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;主要还是管理linux的动态链接库的，安装动态链接库以后，需要将库目录放到 /etc/ld.so.conf 里面，再执行ldconfig，这时候会将库的信息放到  /etc/ld.so.cache（高速缓存机制）。 系统在使用库时候先去 /etc/ld.so.cache 目录下找，找到了再去 /etc/ld.so.conf 目录下找。所以如果  /etc/ld.so.cache 没有，那就找不到。到这里也就明白了，新加库，就要执行ldconfig，但是更新的话就不需要了&lt;/p&gt;

&lt;h3 id=&#34;linux博大精深:41d79fbd6af245a7aa6bb03b7d578a78&#34;&gt;linux博大精深&lt;/h3&gt;

&lt;p&gt;不搞不知道，最近新接的别人的项目，发现写C的还是对底层能更是了解很多啊！linux很多东西用C写起来更能发挥效果啊。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用root用户时候出现权限不够</title>
      <link>http://qwding.github.io/post/root_permissiion_deny/</link>
      <pubDate>Tue, 21 Feb 2017 15:05:28 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/root_permissiion_deny/</guid>
      <description>

&lt;h3 id=&#34;非常费解的问题:0414303b44272975717a1c048b44ad9c&#34;&gt;非常费解的问题&lt;/h3&gt;

&lt;p&gt;写了一个logrotate的脚本，用crontab定时跑，非常费解的问题出现了，我单独跑logrotate怎么跑都没问题，但是放到crontab里就会出现权限不够的问题。其中就有使用curl权限不够，百思不得其姐！&lt;/p&gt;

&lt;p&gt;有没有搞错，我是root用户啊，还出现权限不够的问题。&lt;/p&gt;

&lt;p&gt;试过了将curl权限提到最高，赋给s权限，均失败。&lt;/p&gt;

&lt;p&gt;google查阅curl permission denied  / crontab permission denied  /  logrotate permission denied  均无果。 吐血。。。&lt;/p&gt;

&lt;h3 id=&#34;过程:0414303b44272975717a1c048b44ad9c&#34;&gt;过程&lt;/h3&gt;

&lt;p&gt;查阅系统日志（centos）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cat /var/log/messages |grep curl

 Feb 21 14:52:01 client kernel: type=1400 audit(1487659921.234:2409): avc:  denied  { name_connect } for  pid=26860 comm=&amp;quot;curl&amp;quot; dest=2727 scontext=system_u:system_r:logrotate_t:s0-s0:c0.c1023 tcontext=system_u:object_r:unreserved_port_t:s0 tclass=tcp_socket

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么鬼，看不懂，仔细查阅一下，查到SELinux。&lt;/p&gt;

&lt;p&gt;我去，这不是之前搞mysql常遇到的问题么&lt;/p&gt;

&lt;p&gt;修改 /etc/selinux/config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELINUX=disabled   # 设置为disabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试crontab好使了!&lt;/p&gt;

&lt;h3 id=&#34;selinux:0414303b44272975717a1c048b44ad9c&#34;&gt;SELinux&lt;/h3&gt;

&lt;p&gt;这个是什么美国国家安全局，增加安全控制的东西&lt;/p&gt;

&lt;p&gt;这个设置了enforcing时候，你的root用户其实也没毛多大用了，也是受限制的。&lt;/p&gt;

&lt;p&gt;总之就是不让你动你运行程序以外的文件&lt;/p&gt;

&lt;h3 id=&#34;纠错过程:0414303b44272975717a1c048b44ad9c&#34;&gt;纠错过程&lt;/h3&gt;

&lt;p&gt;很曲折，一直以为是crontab运行时候用户的问题，或者文件的权限问题，在root下还是报错，所以一直卡在那里。 最后能找到问题也是花费好多时间&amp;hellip;&amp;hellip; 好烦&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang 几大主流框架对比</title>
      <link>http://qwding.github.io/post/golang_framwork_pk/</link>
      <pubDate>Fri, 25 Nov 2016 12:48:31 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/golang_framwork_pk/</guid>
      <description>

&lt;h3 id=&#34;先上表格:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;先上表格&lt;/h3&gt;

&lt;p&gt;如下表格是2016-11-24 日调研结果，2~5列为github数据。
&lt;img src=&#34;http://qwding.github.io/img/golang_framwork_pk.png&#34; width = &#34;800&#34; alt=&#34;图片名称&#34; align=center /&gt;&lt;/p&gt;

&lt;p&gt;benchmark:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://qwding.github.io/img/golang_framwork_benchmark.png&#34; width = &#34;800&#34; alt=&#34;图片名称&#34; align=center /&gt;&lt;/p&gt;

&lt;h3 id=&#34;beego-vs-revel-vs-martini-三大老框架:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;beego  VS revel VS martini 三大老框架&lt;/h3&gt;

&lt;p&gt;beego&lt;/p&gt;

&lt;p&gt;beego 很多人比较熟悉，国人写的，框架主要逻辑是经典MVC形式。&lt;/p&gt;

&lt;p&gt;中间件：中间件可以写在beego内置的prepare方法里。&lt;/p&gt;

&lt;p&gt;取参：取Query需要自己提取，url参数可以用内置方法。&lt;/p&gt;

&lt;p&gt;返回：返回比较固定，想修改返回code比较麻烦。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;书写unit testing很恶心。&lt;/p&gt;

&lt;p&gt;他的侵入式代码风格，还有源代码的多层嵌套，很多人都不太喜欢。&lt;/p&gt;

&lt;p&gt;revel&lt;/p&gt;

&lt;p&gt;revel 也是MVC框架，他的的形式是你在一个配置文件配置路由，当用revel工具执行revel run时候，将在项目目录下生产两个文件/tmp/main.go 和 /routs/routs.go .作用分别为注册路由和绑定路由内参数。&lt;/p&gt;

&lt;p&gt;中间件：中间件可以定义在/init.go 里面。&lt;/p&gt;

&lt;p&gt;取参：内置提供方法，并且有自己内置的validation方法，方便。&lt;/p&gt;

&lt;p&gt;返回：提供多种返回方法。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;也是侵入式代码。&lt;/p&gt;

&lt;p&gt;其他的未实际使用，不予评论&lt;/p&gt;

&lt;p&gt;martini&lt;/p&gt;

&lt;p&gt;书写简单，写起来和之后要讲的echo，gin很像，但是他的性能较echo和gin差了很多。&lt;/p&gt;

&lt;p&gt;从功能上说，并且martini并不像beego和revel那样框架全面，需要自己把架子搭起来。&lt;/p&gt;

&lt;p&gt;所以直接就不考虑了。&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;性能上beego和revel两者不分伯仲，两者的侵入式代码也是为了节省更多的时间，带来了不少便利。对比起来更倾向于用revel做简单的web框架，他的取参和返回值带来的便利性更高一点，并且也会生成路由的testing方法，综合来讲下一次如果写简单的管理界面可能考虑使用revel。&lt;/p&gt;

&lt;h3 id=&#34;fasthttp-vs-httprouter:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;fasthttp vs httpRouter&lt;/h3&gt;

&lt;p&gt;两者都作为http的框架，可以替代原生的http，他们的优越都是因为速度快，0占用内存著称。可以考虑将他们作为其他框架的http引擎，会提升很大速度。&lt;/p&gt;

&lt;h3 id=&#34;gorilla-mux:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;gorilla mux&lt;/h3&gt;

&lt;p&gt;gorilla 最大好处是他出发点为组件化，各个模块单独成一体，你需要哪个模块，拿过来用就行，不需要可以换成其他写法。&lt;/p&gt;

&lt;p&gt;mux是帮你对router更容易管理，其速度来说并不是非常突出。但是docker swarm用的是gorilla mux，足见其有一定可用性。&lt;/p&gt;

&lt;p&gt;对于gorilla其他模块，如果缺少哪个模块组件，完全去任你挑选，安全稳定可靠，开发好帮手。&lt;/p&gt;

&lt;h3 id=&#34;echo-vs-gin:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;echo VS gin&lt;/h3&gt;

&lt;p&gt;最想说的两个&lt;/p&gt;

&lt;p&gt;无论哪个benchmark，这两个框架的benchmark都已绝对优势排在前列，性能绝对认可。&lt;/p&gt;

&lt;p&gt;代码书写上，两个框架写法也很相似，非常简洁，几行代码可勾勒一个http server,如下为gin一个ping serve，是不是超级简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;github.com/gin-gonic/gin&amp;quot;
func main() {
    r := gin.Default()
    r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;,
        })
    })
    r.Run() // listen and server on 0.0.0.0:8080
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而echo的写法和gin及其相似，就不列举了。&lt;/p&gt;

&lt;p&gt;功能全面来说，虽然简洁，但是功能也很全面，从路由分组，取参，中间件，返回考虑，都封装的使用很舒服。&lt;/p&gt;

&lt;p&gt;其他特点：&lt;/p&gt;

&lt;p&gt;echo：&lt;/p&gt;

&lt;p&gt;可以将http引擎从 echo.standerd 和fasthttp间切换，两者的性能差不太多。&lt;/p&gt;

&lt;p&gt;自带工具全面：websocket, http2, jwt授权等。&lt;/p&gt;

&lt;p&gt;具有中文文档。&lt;/p&gt;

&lt;p&gt;gin：&lt;/p&gt;

&lt;p&gt;日志跟踪比echo更强大，也内置了返回html文件的方法，所以去写web server也会很简单。&lt;/p&gt;

&lt;p&gt;综合来说&lt;/p&gt;

&lt;p&gt;两者相差不太大，但是gin的日志跟踪还是更舒服一点。&lt;/p&gt;

&lt;p&gt;在以后如果想写简单的API server，我会首选gin或echo来使用，更倾向gin,如果你不想看英文文档可以选择echo。其使用的简单太吸引人了。&lt;/p&gt;

&lt;h3 id=&#34;goji-和-tango:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;goji 和 tango&lt;/h3&gt;

&lt;p&gt;这两个是顺便看的，也有一些人推崇这两个，但是使用起来差别也并不是特别大&lt;/p&gt;

&lt;p&gt;tango出发点是以结构体作为执行体的灵活框架，其他好像也并无特色了&lt;/p&gt;

&lt;p&gt;goji貌似更成熟一点，可依赖程度更高&lt;/p&gt;

&lt;h3 id=&#34;总结:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;萝卜白菜，各有所爱。粗略调研统计，跟上时代步伐。&lt;/p&gt;

&lt;p&gt;总结就是如果写简单web server 会考虑 revel，写api server 会首先考虑gin。&lt;/p&gt;

&lt;h3 id=&#34;福利一句话:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;福利一句话&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;上面的比较仅仅是路由的比较，但99%的瓶颈不在路由，而是模版的渲染和数据库操作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;link:96ab2966d9ab7b0ab7940f829d386302&#34;&gt;LINK&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;revel：&lt;a href=&#34;http://revel.github.io/docs/godoc/template.html&#34;&gt;http://revel.github.io/docs/godoc/template.html &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;revel中文： &lt;a href=&#34;http://gorevel.cn/docs/index.html&#34;&gt;http://gorevel.cn/docs/index.html &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;beego: &lt;a href=&#34;http://beego.me&#34;&gt;http://beego.me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;echo: &lt;a href=&#34;https://echo.labstack.com/guide&#34;&gt;https://echo.labstack.com/guide &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gin: &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;https://github.com/gin-gonic/gin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;httpRouter: &lt;a href=&#34;https://github.com/julienschmidt/httprouter&#34;&gt;https://github.com/julienschmidt/httprouter &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gorilla: &lt;a href=&#34;http://www.gorillatoolkit.org/pkg/&#34;&gt;http://www.gorillatoolkit.org/pkg/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;tango: &lt;a href=&#34;http://gobook.io/read/github.com/go-tango/manual-zh-CN/&#34;&gt;http://gobook.io/read/github.com/go-tango/manual-zh-CN/ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;benchmark:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/smallnest/go-web-framework-benchmark&#34;&gt;https://github.com/smallnest/go-web-framework-benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://colobu.com/2016/03/23/Go-HTTP-request-router-and-web-framework-benchmark/&#34;&gt;http://colobu.com/2016/03/23/Go-HTTP-request-router-and-web-framework-benchmark/ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一场越看越有意思的骂战</title>
      <link>http://qwding.github.io/post/golang_intersting_1/</link>
      <pubDate>Tue, 22 Nov 2016 16:00:09 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/golang_intersting_1/</guid>
      <description>

&lt;h3 id=&#34;有趣的帖子:b429b1d01dbad5b8b090552795c3b36e&#34;&gt;有趣的帖子&lt;/h3&gt;

&lt;p&gt;查些资料，不小心挖了个坟，观战互喷 &lt;a href=&#34;https://www.v2ex.com/t/89374&#34;&gt;https://www.v2ex.com/t/89374&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，看口水战的时候往往还是带了不少信息~&lt;/p&gt;

&lt;p&gt;以此膜拜耿直程序员的耿直精神&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongo 备份</title>
      <link>http://qwding.github.io/post/mongo_backup/</link>
      <pubDate>Thu, 20 Oct 2016 10:37:02 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/mongo_backup/</guid>
      <description>

&lt;h1 id=&#34;mongo-备份:dff5b3233884f61ae2c2815811350b4d&#34;&gt;mongo 备份&lt;/h1&gt;

&lt;p&gt;秉承方便简单，易搭建原则，还是用docker来实现,&lt;a href=&#34;https://hub.docker.com/r/carlding/mongobackup/&#34;&gt;镜像地址（https://hub.docker.com/r/carlding/mongobackup/）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;docker hub找到一个镜像，istepanov/mongodump可以实现本地monogo的备份，查阅其内部脚本，并没有开放传入远程数据库的接口，于是在此基础上改进&lt;/p&gt;

&lt;p&gt;Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM istepanov/mongodump

​MAINTAINER qwding 
ADD backup.sh backup.sh
ADD start.sh start.sh

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;backup.sh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
set -e
echo &amp;quot;Job started: $(date)&amp;quot;
DATE=$(date +%Y%m%d_%H%M%S)
FILE=&amp;quot;/backup/backup-$DATE.tar.gz&amp;quot;
echo &amp;quot;mongodump -h $MONGO_PORT_27017_TCP_ADDR -p $MONGO_PORT_27017_TCP_PORT -u $MONGO_USER -p $MONGO_PASSWORD -d $MONGO_DB&amp;quot;
mongodump -h $MONGO_PORT_27017_TCP_ADDR -u $MONGO_USER -p $MONGO_PASSWORD -d $MONGO_DB
tar -zcvf $FILE dump/
rm -rf dump/
echo &amp;quot;Job finished: $(date)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;start.sh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
set -e
CRON_SCHEDULE=${CRON_SCHEDULE:-0 1 * * *}
if [[ &amp;quot;$1&amp;quot; == &#39;no-cron&#39; ]]; then
    exec /backup.sh
else
    LOGFIFO=&#39;/var/log/cron.fifo&#39;
    if [[ ! -e &amp;quot;$LOGFIFO&amp;quot; ]]; then
        mkfifo &amp;quot;$LOGFIFO&amp;quot;
    fi
    CRON_ENV=&amp;quot;MONGO_PORT_27017_TCP_ADDR=&#39;$MONGO_PORT_27017_TCP_ADDR&#39;&amp;quot;
    CRON_ENV=&amp;quot;$CRON_ENV\nMONGO_USER=&#39;$MONGO_USER&#39;&amp;quot;
    CRON_ENV=&amp;quot;$CRON_ENV\nMONGO_PASSWORD=&#39;$MONGO_PASSWORD&#39;&amp;quot;
    CRON_ENV=&amp;quot;$CRON_ENV\nMONGO_DB=&#39;$MONGO_DB&#39;&amp;quot;
    echo -e &amp;quot;$CRON_ENV\n$CRON_SCHEDULE /backup.sh &amp;gt; $LOGFIFO 2&amp;gt;&amp;amp;1&amp;quot; | crontab -
    crontab -l
    cron
    tail -f &amp;quot;$LOGFIFO&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t carlding/mongobackup . 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -v /root/mongo:/backup -e &#39;CRON_SCHEDULE=0 0 * * *&#39; -e MONGO_PORT_27017_TCP_ADDR=remote.addr:27017 -e MONGO_USER=carlding -e MONGO_PASSWORD=carlding -e MONGO_DB=mongo  carlding/mongobackup 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上为每天零点执行一次mongo备份，并且将备份文件以时间为名字保存在了 /root/mongo目录下&lt;/p&gt;

&lt;p&gt;立即备份：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -v /root/mongo:/backup  -e MONGO_PORT_27017_TCP_ADDR=remote.addr:27017 -e MONGO_USER=carlding -e MONGO_PASSWORD=carlding -e MONGO_DB=mongo  carlding/mongobackup 

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>beego 如何不同环境用不同的runmode</title>
      <link>http://qwding.github.io/post/beego_runmode/</link>
      <pubDate>Wed, 19 Oct 2016 10:28:28 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/beego_runmode/</guid>
      <description>

&lt;h3 id=&#34;beego-runmode修改:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;beego runmode修改&lt;/h3&gt;

&lt;p&gt;除了配置文件设置runmode，想切换环境时候需要手动改，太麻烦，而且容易忘&lt;/p&gt;

&lt;p&gt;想通过如下两种方法尝试，均无效：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flag，但是beego本身并没有flag，简直行不通&lt;/li&gt;
&lt;li&gt;官方文档里个的方法是 beego.Runmode = &amp;ldquo;dev&amp;rdquo;, 但其实这个方法很鸡肋，很蛋疼，因为读配置文件早在程序运行前执行了，而如果再程序里修改runmode，你在init里用的参数必然还是默认写的，用着基本蛋疼。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我在我本地beego 1.7的环境里又尝试了一下，发现已经没有这个方法了，可能作者也觉得确实蛋疼给删了吧。&lt;/p&gt;

&lt;h3 id=&#34;环境变量改变:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;环境变量改变&lt;/h3&gt;

&lt;p&gt;尝试将配置文件的runmode指定为环境变量，然后指定具体模式。发现居然成功了。不管怎么样，确实这个办法还是一个不错的解决方案了&lt;/p&gt;

&lt;h3 id=&#34;加上docker更好用:58592cb27ba0e83c8ed8827df86ec6a9&#34;&gt;加上docker更好用&lt;/h3&gt;

&lt;p&gt;因为本来用docker，这样直接在Dockerfile里设置ENV，部署线上的时候，直接用构建好的镜像启动就ok了，什么都不用改了。&lt;/p&gt;

&lt;p&gt;&lt;i&gt; 懒人使人进步&lt;/i&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How golang slice Semi - pointer.</title>
      <link>http://qwding.github.io/post/slice_args/</link>
      <pubDate>Sun, 09 Oct 2016 19:19:58 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/slice_args/</guid>
      <description>

&lt;h3 id=&#34;起因:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;起因&lt;/h3&gt;

&lt;p&gt;刷leetcode的77题时候，使用了递归方法，并且使用数组时候如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result := make([][]int, 0, length+1)
recursive([]int{}, 1, n, k, result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次使用了cap声明slice，这样的好处是append时候在length后添加数据，并且保证长度够，append时候不会重新申请地址&lt;/p&gt;

&lt;p&gt;但是跑的时候发现，recursive()后，在返回到此段代码，居然什么都没有！result值没变。&lt;/p&gt;

&lt;h1 id=&#34;什么-slice不是传说的指针传递么:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;什么？ slice不是传说的指针传递么？&lt;/h1&gt;

&lt;h1 id=&#34;先看下官方数组结构样子:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;先看下官方数组结构样子&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://qwding.github.io/img/slice.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然，一直知道数组是半指针，就是将数组的地址的值传进去。在函数里是改变不了指针的值，但是可以操作指针指向的数据，详细的google有很多&lt;/p&gt;

&lt;p&gt;我想象的是这样：函数收到的是数组的头地址(就是图最上面的指针）,length和cap等数据，这样可以完全接管数组的操作了&lt;/p&gt;

&lt;p&gt;但是上述起因里出现的问题却不是这样，到底是什么原因呢？于是写了测试代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	result := make([]int, 0, 10)
	addr := &amp;amp;result
	fmt.Println(&amp;quot;result:&amp;quot;, result, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))

	for i := 0; i &amp;lt; 10; i++ {
		functions(result)
		result = append(result, i)
		//appendData(result,i)
	}
	fmt.Println(&amp;quot;result:&amp;quot;, result, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))

}

func functions(arr []int) {
	addr := &amp;amp;arr
	if len(arr) &amp;gt; 0 {
		fmt.Println(&amp;quot;arr:&amp;quot;, arr, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr), &amp;quot;arr 0 addr:&amp;quot;, &amp;amp;arr[0])
	} else {
		fmt.Println(&amp;quot;arr:&amp;quot;, arr, &amp;quot;addr:&amp;quot;, unsafe.Pointer(addr))
	}
}

func appendData(arr []int,data int){
	arr = append(arr,data)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result: [] addr: 0xc420012200
arr: [] addr: 0xc420012260
arr: [0] addr: 0xc4200122a0 arr 0 addr: 0xc4200140f0
arr: [0 1] addr: 0xc4200122e0 arr 0 addr: 0xc4200140f0
arr: [0 1 2] addr: 0xc420012320 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3] addr: 0xc420012360 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4] addr: 0xc4200123a0 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5] addr: 0xc4200123e0 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6] addr: 0xc420012420 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6 7] addr: 0xc420012460 arr 0 addr: 0xc4200140f0
arr: [0 1 2 3 4 5 6 7 8] addr: 0xc4200124a0 arr 0 addr: 0xc4200140f0
result: [0 1 2 3 4 5 6 7 8 9] addr: 0xc420012200
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;居然发现-unsafe-pointer-addr-的值是一直变的-但是-arr-0-是不变的:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;居然发现 unsafe.Pointer(addr)的值是一直变的！但是&amp;amp;arr[0]是不变的！&lt;/h1&gt;

&lt;p&gt;我擦，看来完全想错了，应该是函数里重新创建了一个数组(unsafe.Pointer(addr)一直变说明)，但是把源数组的数据地址拿过来,这个新创建的数组来指向他(&amp;amp;arr[0]不变说明)&lt;/p&gt;

&lt;h1 id=&#34;又测试在function里添加和删除数据-即代码中注释掉的地方去掉-发现返回到main里时是不生效的-所以说明最初猜想是错的:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;又测试在function里添加和删除数据，即代码中注释掉的地方去掉，发现返回到main里时是不生效的，所以说明最初猜想是错的。&lt;/h1&gt;

&lt;h3 id=&#34;修改:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;修改&lt;/h3&gt;

&lt;p&gt;有意思的是当我们修改原有的数据时候，是可以成功的，这就是因为数组元素指向的是原数组的地址，所以修改是生效的&lt;/p&gt;

&lt;h3 id=&#34;妄下结论:ea699c56ae54e9a4b6e2bc03dae237ca&#34;&gt;妄下结论&lt;/h3&gt;

&lt;p&gt;数组在函数传递过程中，在函数里可以更改数组的值，但是不能增和删&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker容器里获取宿主机用户</title>
      <link>http://qwding.github.io/post/get_host_user_in_container/</link>
      <pubDate>Mon, 29 Aug 2016 15:08:37 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/get_host_user_in_container/</guid>
      <description>

&lt;h1 id=&#34;尝试方法:cd3c2658114a3f3f4bebfbdac284dca6&#34;&gt;尝试方法&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;映射宿主机文件到容器，试过几个文件，但是都效果并不好&lt;/li&gt;
&lt;li&gt;启动容器前执行命令将用户写入文件，再启动容器
&lt;code&gt;
echo `echo $USER` &amp;gt; tmp.file &amp;amp;&amp;amp; docker run -it alpine /bin/sh
&lt;/code&gt;
但是遇到问题，就是我在容器的里的程序删除文件会遇到文件忙，没有深究原因&lt;/li&gt;
&lt;li&gt;突然想到了我们启动容器的时候经常用 -v &lt;code&gt;pwd&lt;/code&gt;:/folder。这样应该是执行了shell命令，那么能不能在冒号右侧执行呢。于是测试了一下发现可行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将命令改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it -e HOSTUSER=`echo $USER` apline /bin/sh

//测试
$/ echo $HOSTUSER 
结果正确
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;举一反三:cd3c2658114a3f3f4bebfbdac284dca6&#34;&gt;举一反三&lt;/h3&gt;

&lt;p&gt;既然可以这么获得用户名，那么其实也可以获得其他宿主机信息了，系统信息，能用shell获得的命令，都可以在启动容器时候传入环境变量&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Evernote vs youdao</title>
      <link>http://qwding.github.io/post/evernote_vs_youdao/</link>
      <pubDate>Sun, 28 Aug 2016 23:53:36 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/evernote_vs_youdao/</guid>
      <description>

&lt;h1 id=&#34;evernote:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;Evernote&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;之前一直用evernote，也没发现什么优点，本人流量一直没有超过60M/月限制，所以基本来说只用云笔记部分&lt;/li&gt;
&lt;li&gt;编辑功能，不得不吐槽，我除了会在文本前面加点或者用tab分级外，其他什么编辑功能都不会，甚至有时候被他的带格式粘贴搞迷糊好半天&lt;/li&gt;
&lt;li&gt;编辑工具栏，默认的居然是黑色，字体已经是黑色了，你这个黑色有毛用啊。调个颜色半天都有次还调不出来。&lt;/li&gt;
&lt;li&gt;前几天有出现了限制2台硬件绑定。纳尼？？？弃用弃用，没商量&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;有道云笔记:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;有道云笔记&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;因为国内的好像也就是有道了，其他的有些偏向团队，有些偏向会议之类的&lt;/li&gt;
&lt;li&gt;发现有道的分级比Evernote爽一万倍，虽然功能简单，但是从之前那么蛋疼转过来爽了真的不是一点半点&lt;/li&gt;
&lt;li&gt;发现有道V2.1.0版本居然可以直接将pdf等直接传到目录下直接观看，保存文档，整理笔记更近一步啊！&lt;/li&gt;
&lt;li&gt;有道居然可以用markdown，一些用markdown写的文档直接保存就ok了&lt;/li&gt;
&lt;li&gt;有道有个缺点，就是一次我只圈中了一小部分文档复制，粘贴的时候居然带了整行的格式，日了狗了，恰恰粘贴的是密码，而且是那种特殊密码，以为是密码问题了，搞了好久&lt;/li&gt;
&lt;li&gt;无意间发现点击链接直接在有道内部上网，内部内置了浏览器？吐槽一下，有毛用啊，我肯定是去浏览器查看链接啊&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;vs:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;VS&lt;/h1&gt;

&lt;p&gt;查看两者之后是不是感觉有道云笔记完爆了Evernote，但是，还别急&lt;/p&gt;

&lt;p&gt;用了一阵后，发现&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有道居然超级吃内存，我8G的mac，刚开始用的时候，转移了部分笔记，已经吃到了800M，今天有略加了几个pdf，已经超过1.1G了，笔记容量加起来都不过几十M啊，简直可怕！！！相比之下，evernote一般都保持在200M左右，还是比较安静的，从来不会因为内存着急。&lt;/li&gt;
&lt;li&gt;据他人说，有道想修改附件的话，必须下载下来，编辑后再传上去才行，但是evernote直接可以在线编辑&lt;/li&gt;
&lt;li&gt;有道虽然有markdown，但是不能搜索，原因当然是显示的时候已经转成html，而html并不支持搜索。可是你也可以在md原文搜索啊！但是并没有，也就是说我写了md，就丧失了搜索功能。而我认为在云笔记这么庞大的东西面前，搜索才是最重要的，类似于mac的alfred，快速定位才行。相比evernote搜索用着还是可以接受的，当前目录和全局搜索两选项，而有道只能在当前目录下，如果想搜全局还有用鼠标在点下全局文件夹，恰恰我用的最多的是全局搜索。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;总结:0a0af4fe2c0cfa5f7823691e7b97c81a&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;总的来说，两个都不想用&lt;/p&gt;

&lt;p&gt;Evernote编辑功能不爽，还有设备限制(本人恰巧需要三台)&lt;/p&gt;

&lt;p&gt;有道云笔记太吃内存，如果不吃这么多内存基本就用了，但是吃这么多内存搞得我8G都不够用了&lt;/p&gt;

&lt;p&gt;基本想找一款更好的云笔记软件，也希望获得推荐&lt;/p&gt;

&lt;p&gt;使用体验持续更新&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go map,slice,array 遍历性能测试 </title>
      <link>http://qwding.github.io/post/gotest_map_array_slice/</link>
      <pubDate>Mon, 27 Jun 2016 14:28:44 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/gotest_map_array_slice/</guid>
      <description>

&lt;h1 id=&#34;就是随便试试:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#就是随便试试&lt;/h1&gt;

&lt;p&gt;听说goalng的map和slice的遍历性能差的不是一点半点，于是没事写个benchmark来玩玩
代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package testings

import(
	&amp;quot;testing&amp;quot;
	&amp;quot;strconv&amp;quot;
)

var length = 1000
var maps map[string]string
var slices []string
var arrays [1000]string

func init(){
	maps = make(map[string]string,length)
	slices = make([]string,length)
	for i:=0;i&amp;lt;length;i++{
		maps[strconv.Itoa(i)] = &amp;quot;abc&amp;quot;
		slices[i] = &amp;quot;abc&amp;quot;
		arrays[i] = &amp;quot;abc&amp;quot;
	}

}


func BenchmarkIterateMap(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range maps{
		}
	}
}

func BenchmarkIterateSlices(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range slices{
		}
	}
}

func BenchmarkIterateArrays(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,_ = range arrays{
		}
	}
}

func BenchmarkIterateMapF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range maps{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range slices{
			_ = k
		}
	}
}

func BenchmarkIterateArraysF(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for _,k := range arrays{
			_ = k
		}
	}
}

func BenchmarkIterateSlicesFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_ = slices[j]
		}
	}
}

func BenchmarkIterateArraysFor(b *testing.B){
	for i:=0;i&amp;lt;b.N;i++{
		for j:=0;j&amp;lt;length;j++{
			_= arrays[j]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试结果:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#测试结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;➜  testings git:(master) ✗ go test -bench=. iterate_map_vs_slice_vs_array_test.go
testing: warning: no tests to run
PASS
BenchmarkIterateMap-4      	  100000	     20544 ns/op
BenchmarkIterateSlices-4   	 5000000	       368 ns/op
BenchmarkIterateArrays-4   	 5000000	       371 ns/op
BenchmarkIterateMapF-4     	  100000	     21685 ns/op
BenchmarkIterateSlicesF-4  	 2000000	       812 ns/op
BenchmarkIterateArraysF-4  	 1000000	      1036 ns/op
BenchmarkIterateSlicesFor-4	 1000000	      1199 ns/op
BenchmarkIterateArraysFor-4	 1000000	      1024 ns/op
ok  	command-line-arguments	14.858s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;看数据:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#看数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;先看前面三个方法，只是遍历，没有应用数据，大小都是1000，map 居然是slice和array的57倍之多。&lt;/li&gt;
&lt;li&gt;接下来三个方法是应用到了数据，map性能损耗基本没有增多多少，但是slice和array却增多一倍多（还不了解为什么）&lt;/li&gt;
&lt;li&gt;后面两个表明 array的按index取和range取性能不变，但是slice是有差距的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数据不是固定的:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#数据不是固定的&lt;/h3&gt;

&lt;p&gt;将slice和map的大小分布调成10，100，1000，10000，得出的性能比，map/slice是不固定的，也没有发现什么规律(测试不够充分)，但是一般都在将近30倍以上。但是可以得出遍历性能确实差很多。&lt;/p&gt;

&lt;h3 id=&#34;slice-不同情况性能差距也比较大:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#slice 不同情况性能差距也比较大&lt;/h3&gt;

&lt;h3 id=&#34;遗留问题:b5fc0eddaa47014462e79df04e2285e5&#34;&gt;#遗留问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;slice 为什么只遍历和取到数据还有一倍多的性能损耗&lt;/li&gt;
&lt;li&gt;slice 的index取数和range取数性能也有差距&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>shell execute mongo/mysql which start by docker.</title>
      <link>http://qwding.github.io/post/shell_exec_db/</link>
      <pubDate>Tue, 07 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/shell_exec_db/</guid>
      <description>

&lt;h1 id=&#34;问题初衷:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#问题初衷&lt;/h1&gt;

&lt;p&gt;打算一键部署带权限验证的mongo。但是docker hub官方镜像创建mongo步骤为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name mongodb -d -p 27017:27017 mongo:3.3 --auth
docker exec -it mongodb mongo admin
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打算将其做成脚本&lt;/p&gt;

&lt;h1 id=&#34;用shell实现:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#用shell实现&lt;/h1&gt;

&lt;p&gt;经过查阅，发现shell的 &amp;lt;&amp;lt;EOF 可以实现，查阅资料 &lt;a href=&#34;http://my.oschina.net/u/1032146/blog/146941&#34;&gt;http://my.oschina.net/u/1032146/blog/146941&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;应该可以实现,于是写了脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mongo 启动的容器内执行脚本，成功！&lt;/p&gt;

&lt;h1 id=&#34;直接写脚本启动容器-error:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#直接写脚本启动容器(error)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;!/bin/bash
docker run --name mongodb -d -p 27017:27017 dhub.yunpro.cn/cloud/mongo:3.3 --auth
sleep 1
docker exec -it mongodb mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sleep 1秒是保证mongo起来后才执行exec。&lt;/p&gt;

&lt;p&gt;但是会报错 &lt;code&gt;cannot enable tty mode on non tty input&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为什么报错呢？容器内运行却没问题&lt;/p&gt;

&lt;p&gt;一开始认为是不是docker exec 后面接命令执行 &amp;lt;&amp;lt; EOF 识别不了？想了想不是这么回事&lt;/p&gt;

&lt;p&gt;后来仔细思考了报错，只不过说不能启动一个伪终端，我又想到docker的 i 和 t 参数分别表示输入和伪终端，是不是根本就不需要伪终端啊，于是将 t 参数去掉&lt;/p&gt;

&lt;p&gt;执行成功！&lt;/p&gt;

&lt;h1 id=&#34;总结:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;#总结&lt;/h1&gt;

&lt;p&gt;对shell并不熟悉，也不太深入了解伪终端，但是像这种启动mongo的方法，也类似于启动mysql，执行mysql句子类似，还是应了解每个参数作用&lt;/p&gt;

&lt;h1 id=&#34;附上改后脚本-ok:610a470999a7c01b18f8ed67eb2b53eb&#34;&gt;附上改后脚本(ok)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
docker run --name mongodb -d -p 27017:27017 dhub.yunpro.cn/cloud/mongo:3.3 --auth
sleep 1

docker exec -i mongodb mongo admin &amp;lt;&amp;lt; EOF
db.createUser({ user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } ] });
exit;
EOF
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>golang: change instance address in his method</title>
      <link>http://qwding.github.io/post/golang_struct_func_changeaddr/</link>
      <pubDate>Wed, 01 Jun 2016 19:19:58 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/golang_struct_func_changeaddr/</guid>
      <description>

&lt;h3 id=&#34;前提回顾:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;前提回顾&lt;/h3&gt;

&lt;p&gt;对于结构体中的指针应用，大部分可能知道的是如下两代码的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a *AA) funcA()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func (a AA) funcB()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;区别在于，我们在funcA内修改a的值，是可以成功的，但是在funcB修改a的值是失败的。&lt;/p&gt;

&lt;p&gt;因为funcA中的a是指针传递，funcB中的a是值传递。这个大家都知道。&lt;/p&gt;

&lt;h3 id=&#34;今天话题:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;今天话题&lt;/h3&gt;

&lt;p&gt;先上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type AA struct {
	xyz string
	opq string
}

func (this *AA) Change() {
	b := &amp;amp;AA{xyz: &amp;quot;xyz1&amp;quot;, opq: &amp;quot;opq1&amp;quot;}
	this = b
	fmt.Println(&amp;quot;in this:&amp;quot;, this, &amp;quot;addr:&amp;quot;, &amp;amp;this)
}

func main() {
	a := &amp;amp;AA{xyz: &amp;quot;xyz0&amp;quot;, opq: &amp;quot;opq0&amp;quot;}
	fmt.Println(&amp;quot;before a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)

	a.Change()

	fmt.Println(&amp;quot;after a:&amp;quot;, a, &amp;quot;addr:&amp;quot;, &amp;amp;a)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么问题来了，请回答一下程序执行过程的三个输出是什么。&lt;/p&gt;

&lt;h3 id=&#34;一开始的想法:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;一开始的想法&lt;/h3&gt;

&lt;p&gt;开始简单认为Change方法是指针传递，那么在里面修改了实例的地址，应该是可以实现的，所以&lt;/p&gt;

&lt;p&gt;&lt;code&gt;output1 != output2 == output3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;肯定和预想不一样:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;肯定和预想不一样&lt;/h3&gt;

&lt;p&gt;结果图片如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://qwding.github.io/img/chang_addr.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果： &lt;code&gt;output1  == output3 != output2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;为什么？&lt;/h3&gt;

&lt;p&gt;面向对象的编程，在编译的时候，会将类的方法进行一下转换，类似如下：&lt;/p&gt;

&lt;p&gt;A.f() 会转换成 Object.f(A)&lt;/p&gt;

&lt;p&gt;而转换后的函数方法，也分值传递和指针传递。而这时候是值传递，导致你无论怎么修改A的地址，在函数外面都不会改变。&lt;/p&gt;

&lt;h3 id=&#34;再清晰一点:6a7dc0bc3a90f0304d120c855f7258c9&#34;&gt;再清晰一点&lt;/h3&gt;

&lt;p&gt;可以思考一下堆栈的分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://qwding.github.io/img/chang_addr_pic1.png&#34; alt=&#34; &#34; /&gt;&lt;/p&gt;

&lt;p&gt;手拙，用excel画了个堆栈图&lt;/p&gt;

&lt;p&gt;在执行Chang()时，会生成变量this，这个变量this里存的就是传进来值的地址，main函数里的a变量里存的也是这个地址。
所以修改值得时候，两边是互通的。&lt;/p&gt;

&lt;p&gt;但是，我们Chang()函数是修改的this的值，也就是将 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff00 (a_value)&lt;/code&gt; 改成了 &lt;code&gt;0xffffff04(this) -&amp;gt; 0xffffff10(b_value)&lt;/code&gt;  可是在main函数里面a的值还是没有变。所以output3，还是a指向的地址里的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install portus by docker and configration read.</title>
      <link>http://qwding.github.io/post/portus/</link>
      <pubDate>Wed, 20 Apr 2016 11:48:19 +0800</pubDate>
      
      <guid>http://qwding.github.io/post/portus/</guid>
      <description>

&lt;h3 id=&#34;一般形式:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;一般形式&lt;/h3&gt;

&lt;p&gt;在官方文档，或者百度谷歌，搜到的portus一般都是compose形式搭建，这样好处是操作无脑&lt;/p&gt;

&lt;p&gt;但是一般情况下我们肯定是自己要更灵活一些的，肯定用docker容器形式更舒服一点。可是去dockerhub一搜，各种版本的镜像，查看dockerfile很多人都自己加了一些内容，对于不会ruby的人来说，并不知道那些操作都说干啥的。&lt;/p&gt;

&lt;h3 id=&#34;自己研究研究:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;自己研究研究&lt;/h3&gt;

&lt;p&gt;github master分支上有dockerfile，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM library/rails:4.2.2
MAINTAINER Flavio Castelli &amp;lt;fcastelli@suse.com&amp;gt;

ENV COMPOSE=1
EXPOSE 3000

WORKDIR /portus
COPY Gemfile* ./
RUN bundle install --retry=3

# Install phantomjs, this is required for testing and development purposes
# There are no official deb packages for it, hence we built it inside of the
# open build service.
RUN echo &amp;quot;deb http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/ ./&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list
RUN wget http://download.opensuse.org/repositories/home:/flavio_castelli:/phantomjs/Debian_8.0/Release.key &amp;amp;&amp;amp; \
  apt-key add Release.key &amp;amp;&amp;amp; \
  rm Release.key
RUN apt-get update &amp;amp;&amp;amp; \
    apt-get install -y --no-install-recommends phantomjs &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/*

ADD . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是直接用那个dockerfile直接build一个镜像。参考别人给出的一些docker run参数启动，并成功了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -e RAILS_ENV=production \
	-e RACK_ENV=production \
	-e PORTUS_SECRET_KEY_BASE=secret-goes-here \
	-e PORTUS_KEY_PATH=/certs/server-key.pem \
	-e PORTUS_PASSWORD=portuspw \
	-e PORTUS_CHECK_SSL_USAGE_ENABLED=false \
	-e PORTUS_MACHINE_FQDN_VALUE=192.168.56.101 \
	-e PORTUS_PRODUCTION_HOST=192.168.56.101 \
	-e PORTUS_PRODUCTION_USERNAME=portus \
	-e PORTUS_PRODUCTION_PASSWORD=portus \
	-e PORTUS_PRODUCTION_DATABASE=portus \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	--restart=always \
	-p 5001:3000 portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下这些参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PORTUS_SECRET_KEY_BASE 是rails 4.0以后出的一个web安全参数，一般要rake secret生成一个很长很长的随机串，发现随意写个串也无妨。&lt;/li&gt;
&lt;li&gt;PORTUS_KEY_PATH 猜测是对应registry给出那个crt的。&lt;/li&gt;
&lt;li&gt;PORTUS_PASSWORD 这个参数有意思。在你创建好portus后，需要创建一个用户叫 portus。密码就是这个密码。这个用户的目的是为了同步镜像用的。（之后说）&lt;/li&gt;
&lt;li&gt;PORTUS_CHECK_SSL_USAGE_ENABLED 因为我没有官方签发证书，所以用http，如果https，在registry的notifications时候会发不过去。&lt;/li&gt;
&lt;li&gt;PORTUS_MACHINE_FQDN_VALUE 就是你的portus要配置的域名。&lt;/li&gt;
&lt;li&gt;PORTUS_PRODUCTION_HOST，PORTUS_PRODUCTION_USERNAME，PORTUS_PRODUCTION_PASSWORD，PORTUS_PRODUCTION_DATABASE这几个就是数据库的地址，帐号，密码，数据库&lt;/li&gt;
&lt;li&gt;puma -b tcp://0.0.0.0:3000 -w 3 是执行的CMD，试了一下，这个镜像默认是什么都不执行的，所以启动可以添加这个命令，如果不想每次加可以在dockerfile里加上CMD.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简化一下:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;简化一下&lt;/h3&gt;

&lt;p&gt;显然，如上启动方式跟了一大堆参数是很烦的，也不是你想的。当然那就把它们放到配置文件里。&lt;/p&gt;

&lt;p&gt;主要有三个配置文件都放在了 Portus/config 文件夹下。分别为 config.yml, database.yml, secrets.yml&lt;/p&gt;

&lt;p&gt;将几个env变量都可以配置到文件的production里。&lt;/p&gt;

&lt;p&gt;值得注意的是，PORTUS_MACHINE_FQDN_VALUE这个变量在2.0.3版本里是放在了secrets.yml 里，但是如果你用的是portus的master分支，最新的代码是放在config.yml里的。一坑。&lt;/p&gt;

&lt;p&gt;所以启动方式可以改成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d \
	-e RAILS_ENV=production \
	-e RACK_ENV=production \
	-v /sslkeys:/certs \
	-v /root/terminal/Portus/:/portus \
	-p 5001:3000 \
	--restart=always \
	portus:v1 puma -b tcp://0.0.0.0:3000 -w 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同版本有的参数配置不太一样，参数调整好以后就可以出现登录页面了。就可以开始操作了。&lt;/p&gt;

&lt;h3 id=&#34;镜像同步:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;镜像同步&lt;/h3&gt;

&lt;p&gt;两种方法： 一段时间同步一次。每次push操作更新一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一段时间同步一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我们登录以后，点击admin选项，会出现红色提示，user portus not exist。这时候你可以先创建portus用户，密码为secrets.yml里填写的密码。这个用户的作用就是同步时候用这个用户当做默认用户同步。&lt;/p&gt;

&lt;p&gt;我们在容器里路径为 /Portus 运行 &lt;code&gt;RAILS_ENV=production CATALOG_CRON=&amp;quot;60.seconds&amp;quot; bundle exec crono&lt;/code&gt; 他就会每隔60秒，用用户portus请求一次registry的 /v2/_catalog这个api查阅所有镜像。我们查看portus 容器日志会收到这个用户发来的请求。&lt;/p&gt;

&lt;p&gt;如果你发现同步失败，请检查是否给了portus admin权限，只有admin权限portus才可以访问所有镜像。&lt;/p&gt;

&lt;p&gt;如果想让这个作为单独容器来同步，可以将命令写成个脚本放到portus镜像里 /crono.sh。然后启动容器时候把命令改成 ./crono.sh就行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次push请求一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就是registry 里配置了 notifications，每次push会来向notifications配置的地址发请求。portus server收到请求后来更改数据库。&lt;/p&gt;

&lt;h3 id=&#34;问题:95f2626a8b71aea78c26d5a625e37de7&#34;&gt;问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地配置好以后，想试试域名访问有没有问题，结果改成域名以后一直401。&lt;/p&gt;

&lt;p&gt;后来突然想到，在登录第一次就配置了regitry server信息。应该是这个server名字改变了，所以拒绝了访问。&lt;/p&gt;

&lt;p&gt;修复方法： 直接到数据库的registry表将地址改成域名就行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;push镜像的时候报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error parsing HTTP response: invalid character &#39;&amp;lt;&#39; looking for beginning of value: &amp;quot;&amp;lt;html&amp;gt;\r\n&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;413 Request Entity Too Large&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\r\n&amp;lt;body bgcolor=\&amp;quot;white\&amp;quot;&amp;gt;\r\n&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;413 Request Entity Too Large&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;\r\n&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.9.14&amp;lt;/center&amp;gt;\r\n&amp;lt;/body&amp;gt;\r\n&amp;lt;/html&amp;gt;\r\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题是因为我们使用了http，并配置了nginx，但是默认只有https才允许有basic auth，所以认证失败了。换成https就行。
issue地址：&lt;a href=&#34;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&#34;&gt;https://github.com/docker/docker-registry/issues/298#issuecomment-39845868&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;portus读配置的顺序 配置文件 &amp;gt; -e 参数.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry可以不配置auth并使用portus的，登录portus时候添加registry skip error就可以，但是使用的时候会报很多错误，语言bug，改改代码就ok。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;registry 的issuer 对应的就是portus/config/FQDN的value，文档没有说明白，坑的一逼。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有api，如果不想直接操作web来创建用户等，就需要自己写方法去操作数据库了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>